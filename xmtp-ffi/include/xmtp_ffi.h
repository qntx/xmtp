/* Auto-generated by cbindgen. Do not edit. */

#ifndef XMTP_FFI_H
#define XMTP_FFI_H

/* Warning: this file is autogenously generated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef struct XmtpOption_FnOnCloseCallback XmtpOption_FnOnCloseCallback;

/**
 * Opaque handle for gateway authentication credentials.
 */
typedef struct XmtpXmtpAuthHandle XmtpXmtpAuthHandle;

/**
 * A list of available archives.
 */
typedef struct XmtpXmtpAvailableArchiveList XmtpXmtpAvailableArchiveList;

/**
 * Opaque client handle.
 */
typedef struct XmtpXmtpClient XmtpXmtpClient;

/**
 * Opaque conversation handle.
 */
typedef struct XmtpXmtpConversation XmtpXmtpConversation;

/**
 * A list of conversations returned from queries.
 */
typedef struct XmtpXmtpConversationList XmtpXmtpConversationList;

/**
 * A list of enriched messages.
 */
typedef struct XmtpXmtpEnrichedMessageList XmtpXmtpEnrichedMessageList;

/**
 * A list of group members.
 */
typedef struct XmtpXmtpGroupMemberList XmtpXmtpGroupMemberList;

/**
 * A map of conversation ID → HMAC keys.
 */
typedef struct XmtpXmtpHmacKeyMap XmtpXmtpHmacKeyMap;

/**
 * A list of inbox states.
 */
typedef struct XmtpXmtpInboxStateList XmtpXmtpInboxStateList;

/**
 * A list of inbox update counts.
 */
typedef struct XmtpXmtpInboxUpdateCountList XmtpXmtpInboxUpdateCountList;

/**
 * A list of key package statuses.
 */
typedef struct XmtpXmtpKeyPackageStatusList XmtpXmtpKeyPackageStatusList;

/**
 * A list of last-read-time entries.
 */
typedef struct XmtpXmtpLastReadTimeList XmtpXmtpLastReadTimeList;

/**
 * A stored message exposed to C.
 */
typedef struct XmtpXmtpMessage XmtpXmtpMessage;

/**
 * A list of messages.
 */
typedef struct XmtpXmtpMessageList XmtpXmtpMessageList;

/**
 * Opaque signature request handle.
 */
typedef struct XmtpXmtpSignatureRequest XmtpXmtpSignatureRequest;

/**
 * Opaque stream handle.
 */
typedef struct XmtpXmtpStreamHandle XmtpXmtpStreamHandle;

/**
 * Options for creating a client. All string fields are borrowed (not freed by this library).
 */
typedef struct XmtpXmtpClientOptions {
    /**
     * gRPC host URL (required).
     */
    const char *host;
    /**
     * Whether the connection is TLS-secured.
     */
    int32_t is_secure;
    /**
     * Path to the SQLite database file. Null = ephemeral.
     */
    const char *db_path;
    /**
     * 32-byte encryption key for the database. Null = unencrypted.
     */
    const uint8_t *encryption_key;
    /**
     * Inbox ID (required).
     */
    const char *inbox_id;
    /**
     * Account identifier string (required).
     */
    const char *account_identifier;
    /**
     * Identifier kind: 0 = Ethereum, 1 = Passkey.
     */
    int32_t identifier_kind;
    /**
     * Optional auth handle for gateway authentication. Null = no auth.
     */
    const struct XmtpXmtpAuthHandle *auth_handle;
} XmtpXmtpClientOptions;

/**
 * MLS API call statistics (request counts).
 */
typedef struct XmtpXmtpApiStats {
    int64_t upload_key_package;
    int64_t fetch_key_package;
    int64_t send_group_messages;
    int64_t send_welcome_messages;
    int64_t query_group_messages;
    int64_t query_welcome_messages;
    int64_t subscribe_messages;
    int64_t subscribe_welcomes;
    int64_t publish_commit_log;
    int64_t query_commit_log;
    int64_t get_newest_group_message;
} XmtpXmtpApiStats;

/**
 * Identity API call statistics (request counts).
 */
typedef struct XmtpXmtpIdentityStats {
    int64_t publish_identity_update;
    int64_t get_identity_updates_v2;
    int64_t get_inbox_ids;
    int64_t verify_smart_contract_wallet_signature;
} XmtpXmtpIdentityStats;

/**
 * Options for sending a message.
 */
typedef struct XmtpXmtpSendOpts {
    /**
     * Whether to send a push notification. 1 = yes (default), 0 = no.
     */
    int32_t should_push;
} XmtpXmtpSendOpts;

/**
 * Options for listing messages.
 */
typedef struct XmtpXmtpListMessagesOptions {
    /**
     * Only messages sent after this timestamp (ns). 0 = no filter.
     */
    int64_t sent_after_ns;
    /**
     * Only messages sent before this timestamp (ns). 0 = no filter.
     */
    int64_t sent_before_ns;
    /**
     * Maximum number of messages. 0 = no limit.
     */
    int64_t limit;
    /**
     * Filter by delivery status: -1 = all, 0 = Unpublished, 1 = Published, 2 = Failed.
     */
    int32_t delivery_status;
    /**
     * Filter by message kind: -1 = all, 0 = Application, 1 = MembershipChange.
     */
    int32_t kind;
} XmtpXmtpListMessagesOptions;

/**
 * Options for message disappearing settings.
 */
typedef struct XmtpXmtpDisappearingSettings {
    /**
     * Timestamp (ns) from which messages start disappearing.
     */
    int64_t from_ns;
    /**
     * Duration (ns) after which messages disappear.
     */
    int64_t in_ns;
} XmtpXmtpDisappearingSettings;

/**
 * Conversation debug info (epoch, fork status, commit logs).
 */
typedef struct XmtpXmtpConversationDebugInfo {
    uint64_t epoch;
    int32_t maybe_forked;
    char *fork_details;
    /**
     * -1 = unknown, 0 = no, 1 = yes
     */
    int32_t is_commit_log_forked;
    char *local_commit_log;
    char *remote_commit_log;
} XmtpXmtpConversationDebugInfo;

/**
 * A single HMAC key (42-byte key + epoch).
 */
typedef struct XmtpXmtpHmacKey {
    uint8_t *key;
    int32_t key_len;
    int64_t epoch;
} XmtpXmtpHmacKey;

/**
 * Group metadata (creator + conversation type).
 */
typedef struct XmtpXmtpGroupMetadata {
    /**
     * Creator inbox ID (owned string).
     */
    char *creator_inbox_id;
    /**
     * Conversation type: 0=Group, 1=DM, 2=Sync.
     */
    int32_t conversation_type;
} XmtpXmtpGroupMetadata;

/**
 * Permission policy set for a conversation.
 * Each field is an i32 encoding:
 *   0=Allow, 1=Deny, 2=Admin, 3=SuperAdmin, 4=DoesNotExist, 5=Other
 */
typedef struct XmtpXmtpPermissionPolicySet {
    int32_t add_member_policy;
    int32_t remove_member_policy;
    int32_t add_admin_policy;
    int32_t remove_admin_policy;
    int32_t update_group_name_policy;
    int32_t update_group_description_policy;
    int32_t update_group_image_url_square_policy;
    int32_t update_message_disappearing_policy;
    int32_t update_app_data_policy;
} XmtpXmtpPermissionPolicySet;

/**
 * Group permissions (policy type + policy set).
 */
typedef struct XmtpXmtpGroupPermissions {
    /**
     * 0=Default(AllMembers), 1=AdminOnly, 2=CustomPolicy.
     */
    int32_t policy_type;
    struct XmtpXmtpPermissionPolicySet policy_set;
} XmtpXmtpGroupPermissions;

/**
 * Options for creating a new group conversation.
 */
typedef struct XmtpXmtpCreateGroupOptions {
    /**
     * Permission preset: 0 = AllMembers (default), 1 = AdminOnly.
     */
    int32_t permissions;
    /**
     * Group name (nullable).
     */
    const char *name;
    /**
     * Group description (nullable).
     */
    const char *description;
    /**
     * Group image URL (nullable).
     */
    const char *image_url;
    /**
     * Custom app data string (nullable).
     */
    const char *app_data;
    /**
     * Message disappearing "from" timestamp in ns. 0 = not set.
     */
    int64_t message_disappear_from_ns;
    /**
     * Message disappearing "in" duration in ns. 0 = not set.
     */
    int64_t message_disappear_in_ns;
} XmtpXmtpCreateGroupOptions;

/**
 * Options for listing conversations.
 */
typedef struct XmtpXmtpListConversationsOptions {
    /**
     * Conversation type filter: -1 = all, 0 = DM, 1 = Group.
     */
    int32_t conversation_type;
    /**
     * Maximum number of conversations to return. 0 = no limit.
     */
    int64_t limit;
    /**
     * Only include conversations created after this timestamp (ns). 0 = no filter.
     */
    int64_t created_after_ns;
    /**
     * Only include conversations created before this timestamp (ns). 0 = no filter.
     */
    int64_t created_before_ns;
    /**
     * Consent state filter (parallel array with `consent_states_count`).
     * Values: 0 = Unknown, 1 = Allowed, 2 = Denied.
     */
    const int32_t *consent_states;
    /**
     * Number of consent states in the filter. 0 = no filter.
     */
    int32_t consent_states_count;
    /**
     * Order by: 0 = CreatedAt (default), 1 = LastActivity.
     */
    int32_t order_by;
    /**
     * Whether to include duplicate DMs. 0 = no (default), 1 = yes.
     */
    int32_t include_duplicate_dms;
} XmtpXmtpListConversationsOptions;

/**
 * Options for device sync archive operations.
 */
typedef struct XmtpXmtpArchiveOptions {
    /**
     * Bitmask of element selections: bit 0 = Messages, bit 1 = Consent.
     */
    int32_t elements;
    /**
     * Start timestamp filter (ns). 0 = no filter.
     */
    int64_t start_ns;
    /**
     * End timestamp filter (ns). 0 = no filter.
     */
    int64_t end_ns;
    /**
     * Whether to exclude disappearing messages. 0 = include, 1 = exclude.
     */
    int32_t exclude_disappearing_messages;
} XmtpXmtpArchiveOptions;

/**
 * Callback for conversation stream events.
 */
typedef void (*XmtpFnConversationCallback)(struct XmtpXmtpConversation *conversation, void *context);

/**
 * Callback for message stream events.
 */
typedef void (*XmtpFnMessageCallback)(struct XmtpXmtpMessage *message, void *context);

/**
 * A consent record exposed to C.
 */
typedef struct XmtpXmtpConsentRecord {
    /**
     * Entity type: 0=InboxId, 1=ConversationId
     */
    int32_t entity_type;
    /**
     * Consent state: 0=Unknown, 1=Allowed, 2=Denied
     */
    int32_t state;
    /**
     * Entity identifier string.
     */
    char *entity;
} XmtpXmtpConsentRecord;

/**
 * Callback for consent stream events.
 */
typedef void (*XmtpFnConsentCallback)(struct XmtpXmtpConsentRecord *records,
                                      int32_t count,
                                      void *context);

/**
 * A preference update exposed to C.
 */
typedef struct XmtpXmtpPreferenceUpdate {
    /**
     * Update kind: 0=Consent, 1=HmacKey
     */
    int32_t kind;
    /**
     * For Consent: the consent record. For HmacKey: zeroed.
     */
    struct XmtpXmtpConsentRecord consent;
    /**
     * For HmacKey: the key bytes. For Consent: null/0.
     */
    uint8_t *hmac_key;
    int32_t hmac_key_len;
} XmtpXmtpPreferenceUpdate;

/**
 * Callback for preference stream events.
 */
typedef void (*XmtpFnPreferenceCallback)(struct XmtpXmtpPreferenceUpdate *updates,
                                         int32_t count,
                                         void *context);

/**
 * Callback for message deletion stream events.
 * Receives the message ID as a hex string (caller must free) and context.
 */
typedef void (*XmtpFnMessageDeletionCallback)(char *message_id, void *context);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get the length of the last error message (including NUL terminator).
 * Returns 0 if no error.
 */
xmtp_ int32_t xmtp_last_error_length(void);

/**
 * Copy the last error message into `buf`. Returns bytes written (excluding NUL),
 * or -1 if `buf` is null or too small.
 */
xmtp_ int32_t xmtp_last_error_message(char *buf, int32_t buf_len);

/**
 * Free a string previously returned by this library.
 */
xmtp_ void xmtp_free_string(char *s);

/**
 * Free a byte buffer previously returned by this library.
 */
xmtp_ void xmtp_free_bytes(uint8_t *ptr, int32_t len);

/**
 * Free a string array returned by this library.
 */
xmtp_ void xmtp_free_string_array(char **arr, int32_t count);

/**
 * Initialize the tracing logger. Call at most once. `level` is a C string like
 * "debug", "info", "warn", "error", or "off". Pass null for default ("info").
 * Returns 0 on success.
 */
xmtp_ int32_t xmtp_init_logger(const char *level);

/**
 * Create a new XMTP client. Caller must free with [`xmtp_client_free`].
 */
xmtp_
int32_t xmtp_client_create(const struct XmtpXmtpClientOptions *opts,
                           struct XmtpXmtpClient **out);

/**
 * Get the client's inbox ID. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_client_inbox_id(const struct XmtpXmtpClient *client);

/**
 * Get the client's installation ID (hex). Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_client_installation_id(const struct XmtpXmtpClient *client);

/**
 * Check if the client identity is registered. Returns 1 = yes, 0 = no, -1 = error.
 */
xmtp_ int32_t xmtp_client_is_registered(const struct XmtpXmtpClient *client);

/**
 * Register the client identity with an optional signature request.
 * Pass null for `sig_req` if no external signature is needed.
 */
xmtp_
int32_t xmtp_client_register_identity(const struct XmtpXmtpClient *client,
                                      const struct XmtpXmtpSignatureRequest *sig_req);

/**
 * Check which identifiers can receive messages.
 * `identifiers` is an array of C strings, `kinds` is a parallel array of identifier kinds.
 * Results are written to `out_results` (1 = can message, 0 = cannot).
 */
xmtp_
int32_t xmtp_client_can_message(const struct XmtpXmtpClient *client,
                                const char *const *identifiers,
                                const int32_t *kinds,
                                int32_t count,
                                int32_t *out_results);

/**
 * Release the database connection pool.
 */
xmtp_ int32_t xmtp_client_release_db_connection(const struct XmtpXmtpClient *client);

/**
 * Reconnect to the database.
 */
xmtp_ int32_t xmtp_client_reconnect_db(const struct XmtpXmtpClient *client);

/**
 * Set consent states for multiple entities.
 * `entity_types`: 0 = GroupId, 1 = InboxId.
 * `states`: 0 = Unknown, 1 = Allowed, 2 = Denied.
 */
xmtp_
int32_t xmtp_client_set_consent_states(const struct XmtpXmtpClient *client,
                                       const int32_t *entity_types,
                                       const int32_t *states,
                                       const char *const *entities,
                                       int32_t count);

/**
 * Get consent state for a single entity. Result written to `out_state`.
 */
xmtp_
int32_t xmtp_client_get_consent_state(const struct XmtpXmtpClient *client,
                                      int32_t entity_type,
                                      const char *entity,
                                      int32_t *out_state);

/**
 * Get the inbox state for this client as a single-element list.
 * Caller must free with [`xmtp_inbox_state_list_free`].
 */
xmtp_
int32_t xmtp_client_inbox_state(const struct XmtpXmtpClient *client,
                                int32_t refresh,
                                struct XmtpXmtpInboxStateList **out);

/**
 * Get the client's installation ID as raw bytes.
 * Writes length to `out_len`. Caller must free with [`xmtp_free_bytes`].
 */
xmtp_
uint8_t *xmtp_client_installation_id_bytes(const struct XmtpXmtpClient *client,
                                           int32_t *out_len);

/**
 * Verify a signature produced by `xmtp_client_sign_with_installation_key`.
 * Returns 0 on success (valid), -1 on error (invalid or bad args).
 */
xmtp_
int32_t xmtp_client_verify_signed_with_installation_key(const struct XmtpXmtpClient *client,
                                                        const char *text,
                                                        const uint8_t *signature_bytes,
                                                        int32_t signature_len);

/**
 * Get a message by its hex-encoded ID. Caller must free with [`xmtp_message_free`].
 */
xmtp_
int32_t xmtp_client_get_message_by_id(const struct XmtpXmtpClient *client,
                                      const char *message_id_hex,
                                      struct XmtpXmtpMessage **out);

/**
 * Delete a message by its hex-encoded ID. Returns the number of deleted rows.
 */
xmtp_
int32_t xmtp_client_delete_message_by_id(const struct XmtpXmtpClient *client,
                                         const char *message_id_hex);

/**
 * Get the libxmtp version string. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_libxmtp_version(void);

/**
 * Get MLS API call statistics. Writes to `out`.
 */
xmtp_
int32_t xmtp_client_api_statistics(const struct XmtpXmtpClient *client,
                                   struct XmtpXmtpApiStats *out);

/**
 * Get identity API call statistics. Writes to `out`.
 */
xmtp_
int32_t xmtp_client_api_identity_statistics(const struct XmtpXmtpClient *client,
                                            struct XmtpXmtpIdentityStats *out);

/**
 * Get aggregate statistics as a debug string. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_client_api_aggregate_statistics(const struct XmtpXmtpClient *client);

/**
 * Clear all API call statistics.
 */
xmtp_ int32_t xmtp_client_clear_all_statistics(const struct XmtpXmtpClient *client);

/**
 * Look up an inbox ID by account identifier using the client's connection.
 * Returns null if not found. Caller must free with [`xmtp_free_string`].
 */
xmtp_
int32_t xmtp_client_get_inbox_id_by_identifier(const struct XmtpXmtpClient *client,
                                               const char *identifier,
                                               char **out);

/**
 * Fetch inbox states for multiple inbox IDs.
 * `inbox_ids` is a null-terminated array of C strings with `count` elements.
 * Returns an opaque `XmtpInboxStateList` via `out`. Caller must free with [`xmtp_inbox_state_list_free`].
 */
xmtp_
int32_t xmtp_client_fetch_inbox_states(const struct XmtpXmtpClient *client,
                                       const char *const *inbox_ids,
                                       int32_t count,
                                       int32_t refresh_from_network,
                                       struct XmtpXmtpInboxStateList **out);

/**
 * Get the number of inbox states in the list.
 */
xmtp_ int32_t xmtp_inbox_state_list_len(const struct XmtpXmtpInboxStateList *list);

/**
 * Get inbox ID at index. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_inbox_state_inbox_id(const struct XmtpXmtpInboxStateList *list, int32_t index);

/**
 * Get recovery identifier at index. Caller must free with [`xmtp_free_string`].
 */
xmtp_
char *xmtp_inbox_state_recovery_identifier(const struct XmtpXmtpInboxStateList *list,
                                           int32_t index);

/**
 * Get identifiers array at index. Returns a borrowed pointer; do NOT free.
 */
xmtp_
char *const *xmtp_inbox_state_identifiers(const struct XmtpXmtpInboxStateList *list,
                                          int32_t index,
                                          int32_t *out_count);

/**
 * Get installation IDs (hex) at index. Returns a borrowed pointer; do NOT free.
 */
xmtp_
char *const *xmtp_inbox_state_installation_ids(const struct XmtpXmtpInboxStateList *list,
                                               int32_t index,
                                               int32_t *out_count);

/**
 * Free an inbox state list (including all owned strings).
 */
xmtp_ void xmtp_inbox_state_list_free(struct XmtpXmtpInboxStateList *list);

/**
 * Create a new gateway auth handle. Caller must free with [`xmtp_auth_handle_free`].
 */
xmtp_ int32_t xmtp_auth_handle_create(struct XmtpXmtpAuthHandle **out);

/**
 * Set a credential on an auth handle.
 * `name` is an optional HTTP header name (null = "authorization").
 * `value` is the header value (required).
 * `expires_at_seconds` is the Unix timestamp when the credential expires.
 */
xmtp_
int32_t xmtp_auth_handle_set(const struct XmtpXmtpAuthHandle *handle,
                             const char *name,
                             const char *value,
                             int64_t expires_at_seconds);

/**
 * Get the unique ID of an auth handle.
 */
xmtp_ uintptr_t xmtp_auth_handle_id(const struct XmtpXmtpAuthHandle *handle);

/**
 * Fetch the number of identity updates for multiple inbox IDs.
 * Caller must free the result with [`xmtp_inbox_update_count_list_free`].
 */
xmtp_
int32_t xmtp_client_fetch_inbox_updates_count(const struct XmtpXmtpClient *client,
                                              const char *const *inbox_ids,
                                              int32_t inbox_ids_count,
                                              int32_t refresh,
                                              struct XmtpXmtpInboxUpdateCountList **out);

/**
 * Fetch the number of identity updates for the client's own inbox.
 */
xmtp_
int32_t xmtp_client_fetch_own_inbox_updates_count(const struct XmtpXmtpClient *client,
                                                  int32_t refresh,
                                                  uint32_t *out);

/**
 * Free an inbox update count list.
 */
xmtp_ void xmtp_inbox_update_count_list_free(struct XmtpXmtpInboxUpdateCountList *list);

/**
 * Fetch key package statuses for a list of installation IDs (hex-encoded).
 * Caller must free with [`xmtp_key_package_status_list_free`].
 */
xmtp_
int32_t xmtp_client_fetch_key_package_statuses(const struct XmtpXmtpClient *client,
                                               const char *const *installation_ids,
                                               int32_t installation_ids_count,
                                               struct XmtpXmtpKeyPackageStatusList **out);

/**
 * Free a key package status list.
 */
xmtp_ void xmtp_key_package_status_list_free(struct XmtpXmtpKeyPackageStatusList *list);

/**
 * Get the account identifier string used to create this client.
 * Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_client_account_identifier(const struct XmtpXmtpClient *client);

/**
 * Get the conversation's hex-encoded group ID. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_id(const struct XmtpXmtpConversation *conv);

/**
 * Get the conversation created-at timestamp in nanoseconds.
 */
xmtp_ int64_t xmtp_conversation_created_at_ns(const struct XmtpXmtpConversation *conv);

/**
 * Get the conversation type: 0=DM, 1=Group, 2=Sync, 3=Oneshot, -1=error.
 */
xmtp_ int32_t xmtp_conversation_type(const struct XmtpXmtpConversation *conv);

/**
 * Get the DM peer's inbox ID. Caller must free with [`xmtp_free_string`].
 * Returns null if not a DM or on error.
 */
xmtp_ char *xmtp_conversation_dm_peer_inbox_id(const struct XmtpXmtpConversation *conv);

/**
 * Sync this conversation with the network.
 */
xmtp_ int32_t xmtp_conversation_sync(const struct XmtpXmtpConversation *conv);

/**
 * Send raw encoded content bytes. Returns the message ID (hex) via `out_id`.
 * Caller must free `out_id` with [`xmtp_free_string`].
 * Pass null for `opts` to use defaults (should_push = true).
 */
xmtp_
int32_t xmtp_conversation_send(const struct XmtpXmtpConversation *conv,
                               const uint8_t *content_bytes,
                               int32_t content_len,
                               const struct XmtpXmtpSendOpts *opts,
                               char **out_id);

/**
 * Send raw encoded content bytes optimistically (returns immediately, publishes in background).
 * Returns the message ID (hex) via `out_id`. Caller must free with [`xmtp_free_string`].
 */
xmtp_
int32_t xmtp_conversation_send_optimistic(const struct XmtpXmtpConversation *conv,
                                          const uint8_t *content_bytes,
                                          int32_t content_len,
                                          const struct XmtpXmtpSendOpts *opts,
                                          char **out_id);

/**
 * Publish all queued (unpublished) messages in this conversation.
 */
xmtp_ int32_t xmtp_conversation_publish_messages(const struct XmtpXmtpConversation *conv);

/**
 * Prepare a message for later publishing (optimistic send workflow).
 * Stores the message locally without publishing. Returns message ID (hex) via `out_id`.
 * Caller must free `out_id` with [`xmtp_free_string`].
 */
xmtp_
int32_t xmtp_conversation_prepare_message(const struct XmtpXmtpConversation *conv,
                                          const uint8_t *content_bytes,
                                          int32_t content_len,
                                          int32_t should_push,
                                          char **out_id);

/**
 * Publish a previously prepared message by its hex-encoded ID.
 */
xmtp_
int32_t xmtp_conversation_publish_stored_message(const struct XmtpXmtpConversation *conv,
                                                 const char *message_id_hex);

/**
 * List messages in this conversation. Caller must free with [`xmtp_message_list_free`].
 */
xmtp_
int32_t xmtp_conversation_list_messages(const struct XmtpXmtpConversation *conv,
                                        const struct XmtpXmtpListMessagesOptions *opts,
                                        struct XmtpXmtpMessageList **out);

/**
 * Count messages matching the given filter options.
 * Pass null for `opts` to count all messages.
 */
xmtp_
int64_t xmtp_conversation_count_messages(const struct XmtpXmtpConversation *conv,
                                         const struct XmtpXmtpListMessagesOptions *opts);

/**
 * Get message ID (hex) at index. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_message_id(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get sender inbox ID at index. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_message_sender_inbox_id(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get sent-at timestamp (ns) at index.
 */
xmtp_ int64_t xmtp_message_sent_at_ns(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get message kind at index: 0=Application, 1=MembershipChange, -1=error.
 */
xmtp_ int32_t xmtp_message_kind(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get delivery status at index: 0=Unpublished, 1=Published, 2=Failed, -1=error.
 */
xmtp_ int32_t xmtp_message_delivery_status(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get raw decrypted content bytes at index. Writes length to `out_len`.
 * The returned pointer is borrowed from the list — do NOT free it.
 */
xmtp_
const uint8_t *xmtp_message_content_bytes(const struct XmtpXmtpMessageList *list,
                                          int32_t index,
                                          int32_t *out_len);

/**
 * List group members. Caller must free with [`xmtp_group_member_list_free`].
 */
xmtp_
int32_t xmtp_conversation_list_members(const struct XmtpXmtpConversation *conv,
                                       struct XmtpXmtpGroupMemberList **out);

/**
 * Get member inbox ID at index. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_group_member_inbox_id(const struct XmtpXmtpGroupMemberList *list, int32_t index);

/**
 * Get member permission level at index: 0=Member, 1=Admin, 2=SuperAdmin, -1=error.
 */
xmtp_
int32_t xmtp_group_member_permission_level(const struct XmtpXmtpGroupMemberList *list,
                                           int32_t index);

/**
 * Get member consent state at index: 0=Unknown, 1=Allowed, 2=Denied, -1=error.
 */
xmtp_
int32_t xmtp_group_member_consent_state(const struct XmtpXmtpGroupMemberList *list,
                                        int32_t index);

/**
 * Get member account identifiers at index.
 * Returns a borrowed pointer to the internal string array. Do NOT free individual strings.
 * Use `out_count` to get the number of identifiers.
 */
xmtp_
char *const *xmtp_group_member_account_identifiers(const struct XmtpXmtpGroupMemberList *list,
                                                   int32_t index,
                                                   int32_t *out_count);

/**
 * Get member installation IDs (hex) at index.
 * Returns a borrowed pointer to the internal string array.
 */
xmtp_
char *const *xmtp_group_member_installation_ids(const struct XmtpXmtpGroupMemberList *list,
                                                int32_t index,
                                                int32_t *out_count);

/**
 * Free a group member list (including all owned strings).
 */
xmtp_ void xmtp_group_member_list_free(struct XmtpXmtpGroupMemberList *list);

/**
 * Add members by inbox IDs.
 */
xmtp_
int32_t xmtp_conversation_add_members(const struct XmtpXmtpConversation *conv,
                                      const char *const *inbox_ids,
                                      int32_t count);

/**
 * Remove members by inbox IDs.
 */
xmtp_
int32_t xmtp_conversation_remove_members(const struct XmtpXmtpConversation *conv,
                                         const char *const *inbox_ids,
                                         int32_t count);

/**
 * Leave the group.
 */
xmtp_ int32_t xmtp_conversation_leave(const struct XmtpXmtpConversation *conv);

/**
 * Add/remove admin or super admin. `action`: 0=AddAdmin, 1=RemoveAdmin, 2=AddSuperAdmin, 3=RemoveSuperAdmin.
 */
xmtp_
int32_t xmtp_conversation_update_admin_list(const struct XmtpXmtpConversation *conv,
                                            const char *inbox_id,
                                            int32_t action);

/**
 * Get group name. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_group_name(const struct XmtpXmtpConversation *conv);

/**
 * Update group name.
 */
xmtp_
int32_t xmtp_conversation_update_group_name(const struct XmtpXmtpConversation *conv,
                                            const char *name);

/**
 * Get group description. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_group_description(const struct XmtpXmtpConversation *conv);

/**
 * Update group description.
 */
xmtp_
int32_t xmtp_conversation_update_group_description(const struct XmtpXmtpConversation *conv,
                                                   const char *description);

/**
 * Get group image URL. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_group_image_url(const struct XmtpXmtpConversation *conv);

/**
 * Update group image URL.
 */
xmtp_
int32_t xmtp_conversation_update_group_image_url(const struct XmtpXmtpConversation *conv,
                                                 const char *url);

/**
 * Get conversation consent state. Writes to `out_state` (0=Unknown, 1=Allowed, 2=Denied).
 */
xmtp_
int32_t xmtp_conversation_consent_state(const struct XmtpXmtpConversation *conv,
                                        int32_t *out_state);

/**
 * Update conversation consent state.
 */
xmtp_
int32_t xmtp_conversation_update_consent_state(const struct XmtpXmtpConversation *conv,
                                               int32_t state);

/**
 * Update a permission policy on this conversation.
 * `update_type`: 1=AddMember, 2=RemoveMember, 3=AddAdmin, 4=RemoveAdmin, 5=UpdateMetadata.
 * `policy`: 1=Allow, 2=Deny, 3=AdminOnly, 4=SuperAdminOnly.
 * `metadata_field_name`: Only used when update_type=5 (e.g. "group_name"). Pass null otherwise.
 */
xmtp_
int32_t xmtp_conversation_update_permission_policy(const struct XmtpXmtpConversation *conv,
                                                   int32_t update_type,
                                                   int32_t policy,
                                                   const char *metadata_field_name);

/**
 * Check if the conversation is active. Returns 1=active, 0=inactive, -1=error.
 */
xmtp_ int32_t xmtp_conversation_is_active(const struct XmtpXmtpConversation *conv);

/**
 * Get the membership state of the current user in this conversation.
 * 0=Allowed, 1=Rejected, 2=Pending, 3=Restored, 4=PendingRemove, -1=error.
 */
xmtp_ int32_t xmtp_conversation_membership_state(const struct XmtpXmtpConversation *conv);

/**
 * Get the inbox ID of the member who added the current user.
 * Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_added_by_inbox_id(const struct XmtpXmtpConversation *conv);

/**
 * Get the admin list as a null-terminated array of C strings.
 * `out_count` receives the number of admins.
 * Each string and the array itself must be freed by the caller.
 */
xmtp_
char **xmtp_conversation_list_admins(const struct XmtpXmtpConversation *conv,
                                     int32_t *out_count);

/**
 * Get the super admin list. Same ownership semantics as [`xmtp_conversation_list_admins`].
 */
xmtp_
char **xmtp_conversation_list_super_admins(const struct XmtpXmtpConversation *conv,
                                           int32_t *out_count);

/**
 * Check if an inbox ID is an admin. Returns 1=yes, 0=no, -1=error.
 */
xmtp_
int32_t xmtp_conversation_is_admin(const struct XmtpXmtpConversation *conv,
                                   const char *inbox_id);

/**
 * Check if an inbox ID is a super admin. Returns 1=yes, 0=no, -1=error.
 */
xmtp_
int32_t xmtp_conversation_is_super_admin(const struct XmtpXmtpConversation *conv,
                                         const char *inbox_id);

/**
 * Add members by external identifiers (address/passkey).
 * `identifiers` and `kinds` are parallel arrays of length `count`.
 */
xmtp_
int32_t xmtp_conversation_add_members_by_identity(const struct XmtpXmtpConversation *conv,
                                                  const char *const *identifiers,
                                                  const int32_t *kinds,
                                                  int32_t count);

/**
 * Remove members by external identifiers (address/passkey).
 */
xmtp_
int32_t xmtp_conversation_remove_members_by_identity(const struct XmtpXmtpConversation *conv,
                                                     const char *const *identifiers,
                                                     const int32_t *kinds,
                                                     int32_t count);

/**
 * Update the message disappearing settings for this conversation.
 */
xmtp_
int32_t xmtp_conversation_update_disappearing_settings(const struct XmtpXmtpConversation *conv,
                                                       const struct XmtpXmtpDisappearingSettings *settings);

/**
 * Remove (disable) message disappearing settings for this conversation.
 */
xmtp_
int32_t xmtp_conversation_remove_disappearing_settings(const struct XmtpXmtpConversation *conv);

/**
 * Get the current message disappearing settings.
 * Returns 0 on success (writes to `out`), -1 if not set or on error.
 */
xmtp_
int32_t xmtp_conversation_disappearing_settings(const struct XmtpXmtpConversation *conv,
                                                struct XmtpXmtpDisappearingSettings *out);

/**
 * Check if message disappearing is enabled.
 * Returns 1=enabled, 0=disabled, -1=error.
 */
xmtp_ int32_t xmtp_conversation_is_disappearing_enabled(const struct XmtpXmtpConversation *conv);

/**
 * Get the custom app data string. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_app_data(const struct XmtpXmtpConversation *conv);

/**
 * Update the custom app data string.
 */
xmtp_
int32_t xmtp_conversation_update_app_data(const struct XmtpXmtpConversation *conv,
                                          const char *app_data);

/**
 * Find duplicate DM conversations for this DM.
 * Returns a conversation list. Caller must free with [`xmtp_conversation_list_free`].
 */
xmtp_
int32_t xmtp_conversation_duplicate_dms(const struct XmtpXmtpConversation *conv,
                                        struct XmtpXmtpConversationList **out);

/**
 * Check if the conversation is paused for a version upgrade.
 * Writes the version string to `out` if paused, or null if not paused.
 * Caller must free `out` with [`xmtp_free_string`].
 * Returns 0 on success, -1 on error.
 */
xmtp_
int32_t xmtp_conversation_paused_for_version(const struct XmtpXmtpConversation *conv,
                                             char **out);

/**
 * Get debug info for this conversation.
 * Caller must free string fields with [`xmtp_free_string`].
 */
xmtp_
int32_t xmtp_conversation_debug_info(const struct XmtpXmtpConversation *conv,
                                     struct XmtpXmtpConversationDebugInfo *out);

/**
 * Free a conversation debug info struct (its string fields).
 */
xmtp_ void xmtp_conversation_debug_info_free(struct XmtpXmtpConversationDebugInfo *info);

/**
 * Get HMAC keys for this conversation (including duplicate DMs).
 * Returns a map via `out`. Caller must free with [`xmtp_hmac_key_map_free`].
 */
xmtp_
int32_t xmtp_conversation_hmac_keys(const struct XmtpXmtpConversation *conv,
                                    struct XmtpXmtpHmacKeyMap **out);

/**
 * Get the number of entries in an HMAC key map.
 */
xmtp_ int32_t xmtp_hmac_key_map_len(const struct XmtpXmtpHmacKeyMap *map);

/**
 * Get the group ID (hex) at index. Returns a borrowed pointer; do NOT free.
 */
xmtp_ const char *xmtp_hmac_key_map_group_id(const struct XmtpXmtpHmacKeyMap *map, int32_t index);

/**
 * Get the HMAC keys at index. Writes count to `out_count`.
 * Returns a borrowed pointer to the key array; do NOT free individual keys.
 */
xmtp_
const struct XmtpXmtpHmacKey *xmtp_hmac_key_map_keys(const struct XmtpXmtpHmacKeyMap *map,
                                                     int32_t index,
                                                     int32_t *out_count);

/**
 * Process a raw group message received via push notification.
 * Returns a list of stored messages. Caller must free with [`xmtp_message_list_free`].
 */
xmtp_
int32_t xmtp_conversation_process_streamed_group_message(const struct XmtpXmtpConversation *conversation,
                                                         const uint8_t *envelope_bytes,
                                                         int32_t envelope_bytes_len,
                                                         struct XmtpXmtpMessageList **out);

/**
 * Get the full group metadata (creator inbox ID + conversation type).
 * Caller must free with [`xmtp_group_metadata_free`].
 */
xmtp_
int32_t xmtp_conversation_group_metadata(const struct XmtpXmtpConversation *conversation,
                                         struct XmtpXmtpGroupMetadata **out);

/**
 * Free a group metadata struct.
 */
xmtp_ void xmtp_group_metadata_free(struct XmtpXmtpGroupMetadata *meta);

/**
 * Get the group permissions (policy type + full policy set).
 * Caller must free with [`xmtp_group_permissions_free`].
 */
xmtp_
int32_t xmtp_conversation_group_permissions(const struct XmtpXmtpConversation *conversation,
                                            struct XmtpXmtpGroupPermissions **out);

/**
 * List enriched (decoded) messages for a conversation.
 * Caller must free with [`xmtp_enriched_message_list_free`].
 */
xmtp_
int32_t xmtp_conversation_list_enriched_messages(const struct XmtpXmtpConversation *conversation,
                                                 const struct XmtpXmtpListMessagesOptions *opts,
                                                 struct XmtpXmtpEnrichedMessageList **out);

/**
 * Free an enriched message list.
 */
xmtp_ void xmtp_enriched_message_list_free(struct XmtpXmtpEnrichedMessageList *list);

/**
 * Get per-inbox last read times for a conversation.
 * Caller must free with [`xmtp_last_read_time_list_free`].
 */
xmtp_
int32_t xmtp_conversation_last_read_times(const struct XmtpXmtpConversation *conversation,
                                          struct XmtpXmtpLastReadTimeList **out);

/**
 * Free a last-read-time list.
 */
xmtp_ void xmtp_last_read_time_list_free(struct XmtpXmtpLastReadTimeList *list);

/**
 * Free an HMAC key map (including all owned data).
 */
xmtp_ void xmtp_hmac_key_map_free(struct XmtpXmtpHmacKeyMap *map);

/**
 * Create a new group conversation, optionally adding members by inbox ID.
 * Pass null/0 for `member_inbox_ids`/`member_count` to create an empty group.
 * Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_create_group(const struct XmtpXmtpClient *client,
                                 const struct XmtpXmtpCreateGroupOptions *opts,
                                 const char *const *member_inbox_ids,
                                 int32_t member_count,
                                 struct XmtpXmtpConversation **out);

/**
 * Create a new group, adding members by identity (address/passkey).
 * `identifiers` and `kinds` are parallel arrays of length `count`.
 * Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_create_group_by_identity(const struct XmtpXmtpClient *client,
                                             const struct XmtpXmtpCreateGroupOptions *opts,
                                             const char *const *identifiers,
                                             const int32_t *kinds,
                                             int32_t count,
                                             struct XmtpXmtpConversation **out);

/**
 * Find or create a DM by identifier. Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_create_dm(const struct XmtpXmtpClient *client,
                              const char *identifier,
                              int32_t identifier_kind,
                              struct XmtpXmtpConversation **out);

/**
 * Find or create a DM by inbox ID. Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_find_dm_by_inbox_id(const struct XmtpXmtpClient *client,
                                        const char *inbox_id,
                                        struct XmtpXmtpConversation **out);

/**
 * Create a DM by target inbox ID. Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_create_dm_by_inbox_id(const struct XmtpXmtpClient *client,
                                          const char *inbox_id,
                                          struct XmtpXmtpConversation **out);

/**
 * Get a conversation by hex-encoded group ID.
 * Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_get_conversation_by_id(const struct XmtpXmtpClient *client,
                                           const char *hex_id,
                                           struct XmtpXmtpConversation **out);

/**
 * List conversations. Caller must free result with [`xmtp_conversation_list_free`].
 */
xmtp_
int32_t xmtp_client_list_conversations(const struct XmtpXmtpClient *client,
                                       const struct XmtpXmtpListConversationsOptions *opts,
                                       struct XmtpXmtpConversationList **out);

/**
 * Get a conversation from a list by index. Caller must free with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_conversation_list_get(const struct XmtpXmtpConversationList *list,
                                   int32_t index,
                                   struct XmtpXmtpConversation **out);

/**
 * Free a conversation list.
 */
xmtp_ void xmtp_conversation_list_free(struct XmtpXmtpConversationList *list);

/**
 * Sync welcomes (process new group invitations).
 */
xmtp_ int32_t xmtp_client_sync_welcomes(const struct XmtpXmtpClient *client);

/**
 * Sync all conversations, optionally filtering by consent states.
 * `consent_states` is a parallel array of consent state values (0=Unknown, 1=Allowed, 2=Denied).
 * Pass null and 0 to sync all.
 */
xmtp_
int32_t xmtp_client_sync_all(const struct XmtpXmtpClient *client,
                             const int32_t *consent_states,
                             int32_t consent_states_count,
                             int32_t *out_synced,
                             int32_t *out_eligible);

/**
 * Sync preferences (device sync groups only).
 */
xmtp_
int32_t xmtp_client_sync_preferences(const struct XmtpXmtpClient *client,
                                     int32_t *out_synced,
                                     int32_t *out_eligible);

/**
 * Get HMAC keys for all conversations (including duplicate DMs).
 * Returns a map via `out`. Caller must free with [`xmtp_hmac_key_map_free`].
 */
xmtp_
int32_t xmtp_client_hmac_keys(const struct XmtpXmtpClient *client,
                              struct XmtpXmtpHmacKeyMap **out);

/**
 * Process a raw welcome message received via push notification.
 * Returns a list of conversation handles. Caller must free with [`xmtp_conversation_list_free`].
 */
xmtp_
int32_t xmtp_client_process_streamed_welcome_message(const struct XmtpXmtpClient *client,
                                                     const uint8_t *envelope_bytes,
                                                     int32_t envelope_bytes_len,
                                                     struct XmtpXmtpConversationList **out);

/**
 * Get an enriched (decoded) message by its hex-encoded ID.
 * Caller must free with [`xmtp_enriched_message_list_free`] (single-item list).
 */
xmtp_
int32_t xmtp_client_get_enriched_message_by_id(const struct XmtpXmtpClient *client,
                                               const char *message_id,
                                               struct XmtpXmtpEnrichedMessageList **out);

/**
 * Create a group without syncing members (optimistic / offline-capable).
 * Caller must free with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_create_group_optimistic(const struct XmtpXmtpClient *client,
                                            const struct XmtpXmtpCreateGroupOptions *opts,
                                            struct XmtpXmtpConversation **out);

/**
 * Send a device sync request to retrieve records from another installation.
 */
xmtp_
int32_t xmtp_device_sync_send_request(const struct XmtpXmtpClient *client,
                                      const struct XmtpXmtpArchiveOptions *opts,
                                      const char *server_url);

/**
 * Send a sync archive to the sync group with the given pin.
 */
xmtp_
int32_t xmtp_device_sync_send_archive(const struct XmtpXmtpClient *client,
                                      const struct XmtpXmtpArchiveOptions *opts,
                                      const char *server_url,
                                      const char *pin);

/**
 * Process a sync archive matching the given pin.
 * Pass null for `pin` to process the latest archive.
 */
xmtp_
int32_t xmtp_device_sync_process_archive(const struct XmtpXmtpClient *client,
                                         const char *pin);

/**
 * List archives available for import in the sync group.
 * `days_cutoff` limits how far back to look.
 * Caller must free with [`xmtp_available_archive_list_free`].
 */
xmtp_
int32_t xmtp_device_sync_list_available_archives(const struct XmtpXmtpClient *client,
                                                 int64_t days_cutoff,
                                                 struct XmtpXmtpAvailableArchiveList **out);

/**
 * Get the number of available archives.
 */
xmtp_ int32_t xmtp_available_archive_list_len(const struct XmtpXmtpAvailableArchiveList *list);

/**
 * Get the pin string at index. Returns a borrowed pointer; do NOT free.
 */
xmtp_
const char *xmtp_available_archive_pin(const struct XmtpXmtpAvailableArchiveList *list,
                                       int32_t index);

/**
 * Get the exported_at_ns at index.
 */
xmtp_
int64_t xmtp_available_archive_exported_at_ns(const struct XmtpXmtpAvailableArchiveList *list,
                                              int32_t index);

/**
 * Free an available archive list.
 */
xmtp_ void xmtp_available_archive_list_free(struct XmtpXmtpAvailableArchiveList *list);

/**
 * Export an archive to a local file.
 * `key` must be at least 32 bytes (encryption key).
 */
xmtp_
int32_t xmtp_device_sync_create_archive(const struct XmtpXmtpClient *client,
                                        const char *path,
                                        const struct XmtpXmtpArchiveOptions *opts,
                                        const uint8_t *key,
                                        int32_t key_len);

/**
 * Import a previously exported archive from a file.
 * `key` must be at least 32 bytes (encryption key).
 */
xmtp_
int32_t xmtp_device_sync_import_archive(const struct XmtpXmtpClient *client,
                                        const char *path,
                                        const uint8_t *key,
                                        int32_t key_len);

/**
 * Read metadata from an archive file without loading its full contents.
 * Writes `backup_version` and `exported_at_ns` to the output pointers.
 */
xmtp_
int32_t xmtp_device_sync_archive_metadata(const char *path,
                                          const uint8_t *key,
                                          int32_t key_len,
                                          uint16_t *out_version,
                                          int64_t *out_exported_at_ns);

/**
 * Manually sync all device sync groups.
 * Writes the number of synced/eligible groups to the output pointers.
 */
xmtp_
int32_t xmtp_device_sync_sync_all(const struct XmtpXmtpClient *client,
                                  int32_t *out_synced,
                                  int32_t *out_eligible);

/**
 * Generate an inbox ID from an identifier. Caller must free with [`xmtp_free_string`].
 * `nonce` defaults to 1 if 0 is passed.
 */
xmtp_ char *xmtp_generate_inbox_id(const char *identifier, int32_t identifier_kind, uint64_t nonce);

/**
 * Check whether an installation (by its public key bytes) belongs to an inbox.
 * Returns 1 = authorized, 0 = not authorized. Sets last error on failure.
 */
xmtp_
int32_t xmtp_is_installation_authorized(const char *api_url,
                                        int32_t is_secure,
                                        const char *inbox_id,
                                        const uint8_t *installation_id,
                                        int32_t installation_id_len,
                                        int32_t *out);

/**
 * Check whether an Ethereum address belongs to an inbox.
 * Returns 1 = authorized, 0 = not authorized. Sets last error on failure.
 */
xmtp_
int32_t xmtp_is_address_authorized(const char *api_url,
                                   int32_t is_secure,
                                   const char *inbox_id,
                                   const char *address,
                                   int32_t *out);

/**
 * Get the inbox ID for an identifier by querying the network.
 * `api_url` is the gRPC host, `is_secure` controls TLS.
 * Writes the inbox ID to `out` (caller must free with [`xmtp_free_string`]).
 * Writes null to `out` if no inbox ID is found.
 */
xmtp_
int32_t xmtp_get_inbox_id_for_identifier(const char *api_url,
                                         int32_t is_secure,
                                         const char *identifier,
                                         int32_t identifier_kind,
                                         char **out);

/**
 * Create an inbox registration signature request (if needed).
 * Returns null via `out` if no signature is needed.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_create_inbox_signature_request(const struct XmtpXmtpClient *client,
                                                   struct XmtpXmtpSignatureRequest **out);

/**
 * Create a signature request to add a new identifier.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_add_identifier_signature_request(const struct XmtpXmtpClient *client,
                                                     const char *identifier,
                                                     int32_t identifier_kind,
                                                     struct XmtpXmtpSignatureRequest **out);

/**
 * Create a signature request to revoke an identifier.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_revoke_identifier_signature_request(const struct XmtpXmtpClient *client,
                                                        const char *identifier,
                                                        int32_t identifier_kind,
                                                        struct XmtpXmtpSignatureRequest **out);

/**
 * Create a signature request to revoke all other installations.
 * Returns null via `out` if there are no other installations.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_revoke_all_other_installations(const struct XmtpXmtpClient *client,
                                                   struct XmtpXmtpSignatureRequest **out);

/**
 * Get the human-readable signature text. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_signature_request_text(const struct XmtpXmtpSignatureRequest *req);

/**
 * Add an ECDSA signature to the request.
 */
xmtp_
int32_t xmtp_signature_request_add_ecdsa(const struct XmtpXmtpSignatureRequest *req,
                                         const uint8_t *signature_bytes,
                                         int32_t signature_len);

/**
 * Add a passkey signature to the request.
 * All four byte arrays are required and must not be null.
 */
xmtp_
int32_t xmtp_signature_request_add_passkey(const struct XmtpXmtpSignatureRequest *req,
                                           const uint8_t *public_key,
                                           int32_t public_key_len,
                                           const uint8_t *signature,
                                           int32_t signature_len,
                                           const uint8_t *authenticator_data,
                                           int32_t authenticator_data_len,
                                           const uint8_t *client_data_json,
                                           int32_t client_data_json_len);

/**
 * Add a smart contract wallet (SCW) signature to the request.
 * `account_address` is the EVM account address (hex string).
 * `chain_id` is the EVM chain ID (e.g. 1 for mainnet).
 * `block_number` is optional; pass 0 to omit.
 */
xmtp_
int32_t xmtp_signature_request_add_scw(const struct XmtpXmtpSignatureRequest *req,
                                       const char *account_address,
                                       const uint8_t *signature_bytes,
                                       int32_t signature_len,
                                       uint64_t chain_id,
                                       uint64_t block_number);

/**
 * Apply a signature request to the client.
 */
xmtp_
int32_t xmtp_client_apply_signature_request(const struct XmtpXmtpClient *client,
                                            const struct XmtpXmtpSignatureRequest *req);

/**
 * Free a signature request handle.
 */
xmtp_ void xmtp_signature_request_free(struct XmtpXmtpSignatureRequest *req);

/**
 * Create a signature request to revoke specific installations by their IDs.
 * `installation_ids` is an array of byte arrays, each `id_len` bytes long.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_revoke_installations_signature_request(const struct XmtpXmtpClient *client,
                                                           const uint8_t *const *installation_ids,
                                                           const int32_t *id_lengths,
                                                           int32_t count,
                                                           struct XmtpXmtpSignatureRequest **out);

/**
 * Create a signature request to change the recovery identifier.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_change_recovery_identifier_signature_request(const struct XmtpXmtpClient *client,
                                                                 const char *new_identifier,
                                                                 int32_t identifier_kind,
                                                                 struct XmtpXmtpSignatureRequest **out);

/**
 * Sign text with the client's installation key.
 * Writes signature bytes to `out` and length to `out_len`.
 * Caller must free `out` with [`xmtp_free_bytes`].
 */
xmtp_
int32_t xmtp_client_sign_with_installation_key(const struct XmtpXmtpClient *client,
                                               const char *text,
                                               uint8_t **out,
                                               int32_t *out_len);

/**
 * Verify a signature produced by `sign_with_installation_key` using an
 * arbitrary public key. Does not require a client handle.
 * `signature_bytes` must be exactly 64 bytes, `public_key` must be exactly 32 bytes.
 */
xmtp_
int32_t xmtp_verify_signed_with_public_key(const char *signature_text,
                                           const uint8_t *signature_bytes,
                                           int32_t signature_len,
                                           const uint8_t *public_key,
                                           int32_t public_key_len);

/**
 * Stream new conversations. Calls `callback` for each new conversation.
 * The callback receives a `*mut XmtpConversation` that the caller must free.
 * `context` is an opaque pointer passed through to both callbacks.
 * `on_close` is called when the stream ends (pass null to ignore).
 *
 * Returns a stream handle via `out` that must be closed with [`xmtp_stream_close`].
 */
xmtp_
int32_t xmtp_stream_conversations(const struct XmtpXmtpClient *client,
                                  int32_t conversation_type,
                                  XmtpFnConversationCallback callback,
                                  struct XmtpOption_FnOnCloseCallback on_close,
                                  void *context,
                                  struct XmtpXmtpStreamHandle **out);

/**
 * Stream all messages across conversations.
 * The callback receives a `*mut XmtpMessage` that the caller must free.
 * `consent_states` / `consent_states_count`: optional consent filter (pass null/0 for all).
 * `on_close` is called when the stream ends (pass null to ignore).
 */
xmtp_
int32_t xmtp_stream_all_messages(const struct XmtpXmtpClient *client,
                                 int32_t conversation_type,
                                 const int32_t *consent_states,
                                 int32_t consent_states_count,
                                 XmtpFnMessageCallback callback,
                                 struct XmtpOption_FnOnCloseCallback on_close,
                                 void *context,
                                 struct XmtpXmtpStreamHandle **out);

/**
 * Stream messages for a single conversation.
 * The callback receives a `*mut XmtpMessage` that the caller must free.
 * `on_close` is called when the stream ends (pass null to ignore).
 */
xmtp_
int32_t xmtp_conversation_stream_messages(const struct XmtpXmtpConversation *conv,
                                          XmtpFnMessageCallback callback,
                                          struct XmtpOption_FnOnCloseCallback on_close,
                                          void *context,
                                          struct XmtpXmtpStreamHandle **out);

/**
 * Stream consent state changes. Callback receives an array of consent records.
 * Caller must free each `entity` string in the records after processing.
 */
xmtp_
int32_t xmtp_stream_consent(const struct XmtpXmtpClient *client,
                            XmtpFnConsentCallback callback,
                            struct XmtpOption_FnOnCloseCallback on_close,
                            void *context,
                            struct XmtpXmtpStreamHandle **out);

/**
 * Stream preference updates (consent changes + HMAC key rotations).
 * Callback receives an array of preference updates.
 */
xmtp_
int32_t xmtp_stream_preferences(const struct XmtpXmtpClient *client,
                                XmtpFnPreferenceCallback callback,
                                struct XmtpOption_FnOnCloseCallback on_close,
                                void *context,
                                struct XmtpXmtpStreamHandle **out);

/**
 * Stream message deletion events across all conversations.
 * The callback receives the deleted message ID as a hex string (caller must free).
 */
xmtp_
int32_t xmtp_stream_message_deletions(const struct XmtpXmtpClient *client,
                                      XmtpFnMessageDeletionCallback callback,
                                      void *context,
                                      struct XmtpXmtpStreamHandle **out);

/**
 * Close a stream and stop receiving events.
 */
xmtp_ void xmtp_stream_close(struct XmtpXmtpStreamHandle *handle);

/**
 * Check if a stream is closed. Returns 1 if closed, 0 if active.
 */
xmtp_ int32_t xmtp_stream_is_closed(const struct XmtpXmtpStreamHandle *handle);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* XMTP_FFI_H */
