/* Auto-generated by cbindgen. Do not edit. */

#ifndef XMTP_FFI_H
#define XMTP_FFI_H

/* Warning: this file is autogenously generated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Opaque client handle.
 */
typedef struct XmtpXmtpClient XmtpXmtpClient;

/**
 * Opaque conversation handle.
 */
typedef struct XmtpXmtpConversation XmtpXmtpConversation;

/**
 * A list of conversations returned from queries.
 */
typedef struct XmtpXmtpConversationList XmtpXmtpConversationList;

/**
 * A list of group members.
 */
typedef struct XmtpXmtpGroupMemberList XmtpXmtpGroupMemberList;

/**
 * Opaque inbox state handle.
 */
typedef struct XmtpXmtpInboxState XmtpXmtpInboxState;

/**
 * A stored message exposed to C.
 */
typedef struct XmtpXmtpMessage XmtpXmtpMessage;

/**
 * A list of messages.
 */
typedef struct XmtpXmtpMessageList XmtpXmtpMessageList;

/**
 * Opaque signature request handle.
 */
typedef struct XmtpXmtpSignatureRequest XmtpXmtpSignatureRequest;

/**
 * Opaque stream handle.
 */
typedef struct XmtpXmtpStreamHandle XmtpXmtpStreamHandle;

/**
 * Options for creating a client. All string fields are borrowed (not freed by this library).
 */
typedef struct XmtpXmtpClientOptions {
    /**
     * gRPC host URL (required).
     */
    const char *host;
    /**
     * Whether the connection is TLS-secured.
     */
    int32_t is_secure;
    /**
     * Path to the SQLite database file. Null = ephemeral.
     */
    const char *db_path;
    /**
     * 32-byte encryption key for the database. Null = unencrypted.
     */
    const uint8_t *encryption_key;
    /**
     * Inbox ID (required).
     */
    const char *inbox_id;
    /**
     * Account identifier string (required).
     */
    const char *account_identifier;
    /**
     * Identifier kind: 0 = Ethereum, 1 = Passkey.
     */
    int32_t identifier_kind;
} XmtpXmtpClientOptions;

/**
 * Options for listing messages.
 */
typedef struct XmtpXmtpListMessagesOptions {
    /**
     * Only messages sent after this timestamp (ns). 0 = no filter.
     */
    int64_t sent_after_ns;
    /**
     * Only messages sent before this timestamp (ns). 0 = no filter.
     */
    int64_t sent_before_ns;
    /**
     * Maximum number of messages. 0 = no limit.
     */
    int64_t limit;
} XmtpXmtpListMessagesOptions;

/**
 * Options for creating a new group conversation.
 */
typedef struct XmtpXmtpCreateGroupOptions {
    /**
     * Permission preset: 0 = AllMembers (default), 1 = AdminOnly.
     */
    int32_t permissions;
    /**
     * Group name (nullable).
     */
    const char *name;
    /**
     * Group description (nullable).
     */
    const char *description;
    /**
     * Group image URL (nullable).
     */
    const char *image_url;
} XmtpXmtpCreateGroupOptions;

/**
 * Options for listing conversations.
 */
typedef struct XmtpXmtpListConversationsOptions {
    /**
     * Conversation type filter: -1 = all, 0 = DM, 1 = Group.
     */
    int32_t conversation_type;
    /**
     * Maximum number of conversations to return. 0 = no limit.
     */
    int64_t limit;
    /**
     * Only include conversations created after this timestamp (ns). 0 = no filter.
     */
    int64_t created_after_ns;
    /**
     * Only include conversations created before this timestamp (ns). 0 = no filter.
     */
    int64_t created_before_ns;
} XmtpXmtpListConversationsOptions;

/**
 * Callback for conversation stream events.
 */
typedef void (*XmtpFnConversationCallback)(struct XmtpXmtpConversation *conversation, void *context);

/**
 * Callback for message stream events.
 */
typedef void (*XmtpFnMessageCallback)(struct XmtpXmtpMessage *message, void *context);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get the length of the last error message (including NUL terminator).
 * Returns 0 if no error.
 */
xmtp_ int32_t xmtp_last_error_length(void);

/**
 * Copy the last error message into `buf`. Returns bytes written (excluding NUL),
 * or -1 if `buf` is null or too small.
 */
xmtp_ int32_t xmtp_last_error_message(char *buf, int32_t buf_len);

/**
 * Free a string previously returned by this library.
 */
xmtp_ void xmtp_free_string(char *s);

/**
 * Free a byte buffer previously returned by this library.
 */
xmtp_ void xmtp_free_bytes(uint8_t *ptr, int32_t len);

/**
 * Initialize the tracing logger. Call at most once. `level` is a C string like
 * "debug", "info", "warn", "error", or "off". Pass null for default ("info").
 * Returns 0 on success.
 */
xmtp_ int32_t xmtp_init_logger(const char *level);

/**
 * Create a new XMTP client. Caller must free with [`xmtp_client_free`].
 */
xmtp_
int32_t xmtp_client_create(const struct XmtpXmtpClientOptions *opts,
                           struct XmtpXmtpClient **out);

/**
 * Free a client handle.
 */
xmtp_ void xmtp_client_free(struct XmtpXmtpClient *client);

/**
 * Get the client's inbox ID. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_client_inbox_id(const struct XmtpXmtpClient *client);

/**
 * Get the client's installation ID (hex). Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_client_installation_id(const struct XmtpXmtpClient *client);

/**
 * Check if the client identity is registered. Returns 1 = yes, 0 = no, -1 = error.
 */
xmtp_ int32_t xmtp_client_is_registered(const struct XmtpXmtpClient *client);

/**
 * Register the client identity with an optional signature request.
 * Pass null for `sig_req` if no external signature is needed.
 */
xmtp_
int32_t xmtp_client_register_identity(const struct XmtpXmtpClient *client,
                                      const struct XmtpXmtpSignatureRequest *sig_req);

/**
 * Check which identifiers can receive messages.
 * `identifiers` is an array of C strings, `kinds` is a parallel array of identifier kinds.
 * Results are written to `out_results` (1 = can message, 0 = cannot).
 */
xmtp_
int32_t xmtp_client_can_message(const struct XmtpXmtpClient *client,
                                const char *const *identifiers,
                                const int32_t *kinds,
                                int32_t count,
                                int32_t *out_results);

/**
 * Release the database connection pool.
 */
xmtp_ int32_t xmtp_client_release_db_connection(const struct XmtpXmtpClient *client);

/**
 * Reconnect to the database.
 */
xmtp_ int32_t xmtp_client_reconnect_db(const struct XmtpXmtpClient *client);

/**
 * Set consent states for multiple entities.
 * `entity_types`: 0 = GroupId, 1 = InboxId.
 * `states`: 0 = Unknown, 1 = Allowed, 2 = Denied.
 */
xmtp_
int32_t xmtp_client_set_consent_states(const struct XmtpXmtpClient *client,
                                       const int32_t *entity_types,
                                       const int32_t *states,
                                       const char *const *entities,
                                       int32_t count);

/**
 * Get consent state for a single entity. Result written to `out_state`.
 */
xmtp_
int32_t xmtp_client_get_consent_state(const struct XmtpXmtpClient *client,
                                      int32_t entity_type,
                                      const char *entity,
                                      int32_t *out_state);

/**
 * Get the inbox state for this client. Caller must free with [`xmtp_inbox_state_free`].
 */
xmtp_
int32_t xmtp_client_inbox_state(const struct XmtpXmtpClient *client,
                                int32_t refresh,
                                struct XmtpXmtpInboxState **out);

/**
 * Get the inbox ID from an inbox state. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_inbox_state_inbox_id(const struct XmtpXmtpInboxState *state);

/**
 * Get the number of installations from an inbox state.
 */
xmtp_ int32_t xmtp_inbox_state_installation_count(const struct XmtpXmtpInboxState *state);

/**
 * Free an inbox state handle.
 */
xmtp_ void xmtp_inbox_state_free(struct XmtpXmtpInboxState *state);

/**
 * Get the client's installation ID as raw bytes.
 * Writes length to `out_len`. Caller must free with [`xmtp_free_bytes`].
 */
xmtp_
uint8_t *xmtp_client_installation_id_bytes(const struct XmtpXmtpClient *client,
                                           int32_t *out_len);

/**
 * Verify a signature produced by `xmtp_client_sign_with_installation_key`.
 * Returns 0 on success (valid), -1 on error (invalid or bad args).
 */
xmtp_
int32_t xmtp_client_verify_signed_with_installation_key(const struct XmtpXmtpClient *client,
                                                        const char *text,
                                                        const uint8_t *signature_bytes,
                                                        int32_t signature_len);

/**
 * Free a conversation handle.
 */
xmtp_ void xmtp_conversation_free(struct XmtpXmtpConversation *conv);

/**
 * Get the conversation's hex-encoded group ID. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_id(const struct XmtpXmtpConversation *conv);

/**
 * Get the conversation created-at timestamp in nanoseconds.
 */
xmtp_ int64_t xmtp_conversation_created_at_ns(const struct XmtpXmtpConversation *conv);

/**
 * Get the conversation type: 0=DM, 1=Group, 2=Sync, 3=Oneshot, -1=error.
 */
xmtp_ int32_t xmtp_conversation_type(const struct XmtpXmtpConversation *conv);

/**
 * Get the DM peer's inbox ID. Caller must free with [`xmtp_free_string`].
 * Returns null if not a DM.
 */
xmtp_ char *xmtp_conversation_dm_peer_inbox_id(const struct XmtpXmtpConversation *conv);

/**
 * Sync this conversation with the network.
 */
xmtp_ int32_t xmtp_conversation_sync(const struct XmtpXmtpConversation *conv);

/**
 * Send raw encoded content bytes. Returns the message ID (hex) via `out_id`.
 * Caller must free `out_id` with [`xmtp_free_string`].
 */
xmtp_
int32_t xmtp_conversation_send(const struct XmtpXmtpConversation *conv,
                               const uint8_t *content_bytes,
                               int32_t content_len,
                               char **out_id);

/**
 * List messages in this conversation. Caller must free with [`xmtp_message_list_free`].
 */
xmtp_
int32_t xmtp_conversation_list_messages(const struct XmtpXmtpConversation *conv,
                                        const struct XmtpXmtpListMessagesOptions *opts,
                                        struct XmtpXmtpMessageList **out);

/**
 * Get the number of messages in a list.
 */
xmtp_ int32_t xmtp_message_list_len(const struct XmtpXmtpMessageList *list);

/**
 * Get message ID (hex) at index. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_message_id(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get sender inbox ID at index. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_message_sender_inbox_id(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get sent-at timestamp (ns) at index.
 */
xmtp_ int64_t xmtp_message_sent_at_ns(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get message kind at index: 0=Application, 1=MembershipChange, -1=error.
 */
xmtp_ int32_t xmtp_message_kind(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get delivery status at index: 0=Unpublished, 1=Published, 2=Failed, -1=error.
 */
xmtp_ int32_t xmtp_message_delivery_status(const struct XmtpXmtpMessageList *list, int32_t index);

/**
 * Get raw decrypted content bytes at index. Writes length to `out_len`.
 * The returned pointer is borrowed from the list â€” do NOT free it.
 */
xmtp_
const uint8_t *xmtp_message_content_bytes(const struct XmtpXmtpMessageList *list,
                                          int32_t index,
                                          int32_t *out_len);

/**
 * Free a message list.
 */
xmtp_ void xmtp_message_list_free(struct XmtpXmtpMessageList *list);

/**
 * Free a single message.
 */
xmtp_ void xmtp_message_free(struct XmtpXmtpMessage *msg);

/**
 * List group members. Caller must free with [`xmtp_group_member_list_free`].
 */
xmtp_
int32_t xmtp_conversation_list_members(const struct XmtpXmtpConversation *conv,
                                       struct XmtpXmtpGroupMemberList **out);

/**
 * Get number of members in a list.
 */
xmtp_ int32_t xmtp_group_member_list_len(const struct XmtpXmtpGroupMemberList *list);

/**
 * Get member inbox ID at index. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_group_member_inbox_id(const struct XmtpXmtpGroupMemberList *list, int32_t index);

/**
 * Get member permission level at index: 0=Member, 1=Admin, 2=SuperAdmin, -1=error.
 */
xmtp_
int32_t xmtp_group_member_permission_level(const struct XmtpXmtpGroupMemberList *list,
                                           int32_t index);

/**
 * Free a group member list.
 */
xmtp_ void xmtp_group_member_list_free(struct XmtpXmtpGroupMemberList *list);

/**
 * Add members by inbox IDs.
 */
xmtp_
int32_t xmtp_conversation_add_members(const struct XmtpXmtpConversation *conv,
                                      const char *const *inbox_ids,
                                      int32_t count);

/**
 * Remove members by inbox IDs.
 */
xmtp_
int32_t xmtp_conversation_remove_members(const struct XmtpXmtpConversation *conv,
                                         const char *const *inbox_ids,
                                         int32_t count);

/**
 * Leave the group.
 */
xmtp_ int32_t xmtp_conversation_leave(const struct XmtpXmtpConversation *conv);

/**
 * Add/remove admin or super admin. `action`: 0=AddAdmin, 1=RemoveAdmin, 2=AddSuperAdmin, 3=RemoveSuperAdmin.
 */
xmtp_
int32_t xmtp_conversation_update_admin_list(const struct XmtpXmtpConversation *conv,
                                            const char *inbox_id,
                                            int32_t action);

/**
 * Get group name. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_group_name(const struct XmtpXmtpConversation *conv);

/**
 * Update group name.
 */
xmtp_
int32_t xmtp_conversation_update_group_name(const struct XmtpXmtpConversation *conv,
                                            const char *name);

/**
 * Get group description. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_group_description(const struct XmtpXmtpConversation *conv);

/**
 * Update group description.
 */
xmtp_
int32_t xmtp_conversation_update_group_description(const struct XmtpXmtpConversation *conv,
                                                   const char *description);

/**
 * Get group image URL. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_group_image_url(const struct XmtpXmtpConversation *conv);

/**
 * Update group image URL.
 */
xmtp_
int32_t xmtp_conversation_update_group_image_url(const struct XmtpXmtpConversation *conv,
                                                 const char *url);

/**
 * Get conversation consent state. Writes to `out_state` (0=Unknown, 1=Allowed, 2=Denied).
 */
xmtp_
int32_t xmtp_conversation_consent_state(const struct XmtpXmtpConversation *conv,
                                        int32_t *out_state);

/**
 * Update conversation consent state.
 */
xmtp_
int32_t xmtp_conversation_update_consent_state(const struct XmtpXmtpConversation *conv,
                                               int32_t state);

/**
 * Update a permission policy on this conversation.
 * `update_type`: 1=AddMember, 2=RemoveMember, 3=AddAdmin, 4=RemoveAdmin, 5=UpdateMetadata.
 * `policy`: 1=Allow, 2=Deny, 3=AdminOnly, 4=SuperAdminOnly.
 * `metadata_field_name`: Only used when update_type=5 (e.g. "group_name"). Pass null otherwise.
 */
xmtp_
int32_t xmtp_conversation_update_permission_policy(const struct XmtpXmtpConversation *conv,
                                                   int32_t update_type,
                                                   int32_t policy,
                                                   const char *metadata_field_name);

/**
 * Check if the conversation is active. Returns 1=active, 0=inactive, -1=error.
 */
xmtp_ int32_t xmtp_conversation_is_active(const struct XmtpXmtpConversation *conv);

/**
 * Get the membership state of the current user in this conversation.
 * 0=Allowed, 1=Rejected, 2=Pending, 3=Restored, 4=PendingRemove, -1=error.
 */
xmtp_ int32_t xmtp_conversation_membership_state(const struct XmtpXmtpConversation *conv);

/**
 * Get the inbox ID of the member who added the current user.
 * Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_conversation_added_by_inbox_id(const struct XmtpXmtpConversation *conv);

/**
 * Get the admin list as a null-terminated array of C strings.
 * `out_count` receives the number of admins.
 * Each string and the array itself must be freed by the caller.
 */
xmtp_
char **xmtp_conversation_list_admins(const struct XmtpXmtpConversation *conv,
                                     int32_t *out_count);

/**
 * Get the super admin list. Same ownership semantics as [`xmtp_conversation_list_admins`].
 */
xmtp_
char **xmtp_conversation_list_super_admins(const struct XmtpXmtpConversation *conv,
                                           int32_t *out_count);

/**
 * Check if an inbox ID is an admin. Returns 1=yes, 0=no, -1=error.
 */
xmtp_
int32_t xmtp_conversation_is_admin(const struct XmtpXmtpConversation *conv,
                                   const char *inbox_id);

/**
 * Check if an inbox ID is a super admin. Returns 1=yes, 0=no, -1=error.
 */
xmtp_
int32_t xmtp_conversation_is_super_admin(const struct XmtpXmtpConversation *conv,
                                         const char *inbox_id);

/**
 * Add members by external identifiers (address/passkey).
 * `identifiers` and `kinds` are parallel arrays of length `count`.
 */
xmtp_
int32_t xmtp_conversation_add_members_by_identity(const struct XmtpXmtpConversation *conv,
                                                  const char *const *identifiers,
                                                  const int32_t *kinds,
                                                  int32_t count);

/**
 * Remove members by external identifiers (address/passkey).
 */
xmtp_
int32_t xmtp_conversation_remove_members_by_identity(const struct XmtpXmtpConversation *conv,
                                                     const char *const *identifiers,
                                                     const int32_t *kinds,
                                                     int32_t count);

/**
 * Free a string array returned by `xmtp_conversation_list_admins` etc.
 */
xmtp_ void xmtp_free_string_array(char **arr, int32_t count);

/**
 * Create a new group conversation. Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_create_group(const struct XmtpXmtpClient *client,
                                 const struct XmtpXmtpCreateGroupOptions *opts,
                                 struct XmtpXmtpConversation **out);

/**
 * Find or create a DM by identifier. Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_create_dm(const struct XmtpXmtpClient *client,
                              const char *identifier,
                              int32_t identifier_kind,
                              struct XmtpXmtpConversation **out);

/**
 * Find or create a DM by inbox ID. Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_find_dm_by_inbox_id(const struct XmtpXmtpClient *client,
                                        const char *inbox_id,
                                        struct XmtpXmtpConversation **out);

/**
 * Get a conversation by hex-encoded group ID.
 * Caller must free result with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_client_get_conversation_by_id(const struct XmtpXmtpClient *client,
                                           const char *hex_id,
                                           struct XmtpXmtpConversation **out);

/**
 * List conversations. Caller must free result with [`xmtp_conversation_list_free`].
 */
xmtp_
int32_t xmtp_client_list_conversations(const struct XmtpXmtpClient *client,
                                       const struct XmtpXmtpListConversationsOptions *opts,
                                       struct XmtpXmtpConversationList **out);

/**
 * Get the number of conversations in a list.
 */
xmtp_ int32_t xmtp_conversation_list_len(const struct XmtpXmtpConversationList *list);

/**
 * Get a conversation from a list by index. Caller must free with [`xmtp_conversation_free`].
 */
xmtp_
int32_t xmtp_conversation_list_get(const struct XmtpXmtpConversationList *list,
                                   int32_t index,
                                   struct XmtpXmtpConversation **out);

/**
 * Free a conversation list.
 */
xmtp_ void xmtp_conversation_list_free(struct XmtpXmtpConversationList *list);

/**
 * Sync welcomes (process new group invitations).
 */
xmtp_ int32_t xmtp_client_sync_welcomes(const struct XmtpXmtpClient *client);

/**
 * Sync all conversations. Writes summary counts to `out_synced` and `out_eligible`.
 */
xmtp_
int32_t xmtp_client_sync_all(const struct XmtpXmtpClient *client,
                             int32_t *out_synced,
                             int32_t *out_eligible);

/**
 * Generate an inbox ID from an identifier. Caller must free with [`xmtp_free_string`].
 * `nonce` defaults to 1 if 0 is passed.
 */
xmtp_ char *xmtp_generate_inbox_id(const char *identifier, int32_t identifier_kind, uint64_t nonce);

/**
 * Get the inbox ID for an identifier by querying the network.
 * `api_url` is the gRPC host, `is_secure` controls TLS.
 * Writes the inbox ID to `out` (caller must free with [`xmtp_free_string`]).
 * Writes null to `out` if no inbox ID is found.
 */
xmtp_
int32_t xmtp_get_inbox_id_for_identifier(const char *api_url,
                                         int32_t is_secure,
                                         const char *identifier,
                                         int32_t identifier_kind,
                                         char **out);

/**
 * Create an inbox registration signature request (if needed).
 * Returns null via `out` if no signature is needed.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_create_inbox_signature_request(const struct XmtpXmtpClient *client,
                                                   struct XmtpXmtpSignatureRequest **out);

/**
 * Create a signature request to add a new identifier.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_add_identifier_signature_request(const struct XmtpXmtpClient *client,
                                                     const char *identifier,
                                                     int32_t identifier_kind,
                                                     struct XmtpXmtpSignatureRequest **out);

/**
 * Create a signature request to revoke an identifier.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_revoke_identifier_signature_request(const struct XmtpXmtpClient *client,
                                                        const char *identifier,
                                                        int32_t identifier_kind,
                                                        struct XmtpXmtpSignatureRequest **out);

/**
 * Create a signature request to revoke all other installations.
 * Returns null via `out` if there are no other installations.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_revoke_all_other_installations(const struct XmtpXmtpClient *client,
                                                   struct XmtpXmtpSignatureRequest **out);

/**
 * Get the human-readable signature text. Caller must free with [`xmtp_free_string`].
 */
xmtp_ char *xmtp_signature_request_text(const struct XmtpXmtpSignatureRequest *req);

/**
 * Add an ECDSA signature to the request.
 */
xmtp_
int32_t xmtp_signature_request_add_ecdsa(const struct XmtpXmtpSignatureRequest *req,
                                         const uint8_t *signature_bytes,
                                         int32_t signature_len);

/**
 * Apply a signature request to the client.
 */
xmtp_
int32_t xmtp_client_apply_signature_request(const struct XmtpXmtpClient *client,
                                            const struct XmtpXmtpSignatureRequest *req);

/**
 * Free a signature request handle.
 */
xmtp_ void xmtp_signature_request_free(struct XmtpXmtpSignatureRequest *req);

/**
 * Create a signature request to revoke specific installations by their IDs.
 * `installation_ids` is an array of byte arrays, each `id_len` bytes long.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_revoke_installations_signature_request(const struct XmtpXmtpClient *client,
                                                           const uint8_t *const *installation_ids,
                                                           const int32_t *id_lengths,
                                                           int32_t count,
                                                           struct XmtpXmtpSignatureRequest **out);

/**
 * Create a signature request to change the recovery identifier.
 * Caller must free with [`xmtp_signature_request_free`].
 */
xmtp_
int32_t xmtp_client_change_recovery_identifier_signature_request(const struct XmtpXmtpClient *client,
                                                                 const char *new_identifier,
                                                                 int32_t identifier_kind,
                                                                 struct XmtpXmtpSignatureRequest **out);

/**
 * Sign text with the client's installation key.
 * Writes signature bytes to `out` and length to `out_len`.
 * Caller must free `out` with [`xmtp_free_bytes`].
 */
xmtp_
int32_t xmtp_client_sign_with_installation_key(const struct XmtpXmtpClient *client,
                                               const char *text,
                                               uint8_t **out,
                                               int32_t *out_len);

/**
 * Stream new conversations. Calls `callback` for each new conversation.
 * The callback receives a `*mut XmtpConversation` that the caller must free.
 * `context` is an opaque pointer passed through to the callback.
 *
 * Returns a stream handle via `out` that must be closed with [`xmtp_stream_close`].
 */
xmtp_
int32_t xmtp_stream_conversations(const struct XmtpXmtpClient *client,
                                  int32_t conversation_type,
                                  XmtpFnConversationCallback callback,
                                  void *context,
                                  struct XmtpXmtpStreamHandle **out);

/**
 * Stream all messages across conversations.
 * The callback receives a `*mut XmtpMessage` that the caller must free.
 */
xmtp_
int32_t xmtp_stream_all_messages(const struct XmtpXmtpClient *client,
                                 int32_t conversation_type,
                                 XmtpFnMessageCallback callback,
                                 void *context,
                                 struct XmtpXmtpStreamHandle **out);

/**
 * Stream messages for a single conversation.
 * The callback receives a `*mut XmtpMessage` that the caller must free.
 */
xmtp_
int32_t xmtp_conversation_stream_messages(const struct XmtpXmtpConversation *conv,
                                          XmtpFnMessageCallback callback,
                                          void *context,
                                          struct XmtpXmtpStreamHandle **out);

/**
 * Close a stream and stop receiving events.
 */
xmtp_ void xmtp_stream_close(struct XmtpXmtpStreamHandle *handle);

/**
 * Check if a stream is closed. Returns 1 if closed, 0 if active.
 */
xmtp_ int32_t xmtp_stream_is_closed(const struct XmtpXmtpStreamHandle *handle);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* XMTP_FFI_H */
