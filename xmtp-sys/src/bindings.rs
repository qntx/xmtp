/* automatically generated by rust-bindgen 0.72.1 */

#[repr(i32)]
#[non_exhaustive]
#[doc = " Conversation type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmtpFfiConversationType {
    XMTP_FFI_CONVERSATION_TYPE_DM = 0,
    XMTP_FFI_CONVERSATION_TYPE_GROUP = 1,
    XMTP_FFI_CONVERSATION_TYPE_SYNC = 2,
    XMTP_FFI_CONVERSATION_TYPE_ONESHOT = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Group permissions preset."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmtpFfiGroupPermissionsPreset {
    XMTP_FFI_GROUP_PERMISSIONS_PRESET_ALL_MEMBERS = 0,
    XMTP_FFI_GROUP_PERMISSIONS_PRESET_ADMIN_ONLY = 1,
    XMTP_FFI_GROUP_PERMISSIONS_PRESET_CUSTOM = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Permission policy value."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmtpFfiPermissionPolicy {
    XMTP_FFI_PERMISSION_POLICY_ALLOW = 0,
    XMTP_FFI_PERMISSION_POLICY_DENY = 1,
    XMTP_FFI_PERMISSION_POLICY_ADMIN = 2,
    XMTP_FFI_PERMISSION_POLICY_SUPER_ADMIN = 3,
    XMTP_FFI_PERMISSION_POLICY_DOES_NOT_EXIST = 4,
    XMTP_FFI_PERMISSION_POLICY_OTHER = 5,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Message kind."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmtpFfiMessageKind {
    XMTP_FFI_MESSAGE_KIND_APPLICATION = 0,
    XMTP_FFI_MESSAGE_KIND_MEMBERSHIP_CHANGE = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Message delivery status."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmtpFfiDeliveryStatus {
    XMTP_FFI_DELIVERY_STATUS_UNPUBLISHED = 0,
    XMTP_FFI_DELIVERY_STATUS_PUBLISHED = 1,
    XMTP_FFI_DELIVERY_STATUS_FAILED = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Consent entity type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmtpFfiConsentEntityType {
    XMTP_FFI_CONSENT_ENTITY_TYPE_GROUP_ID = 0,
    XMTP_FFI_CONSENT_ENTITY_TYPE_INBOX_ID = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Consent state for an entity."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmtpFfiConsentState {
    XMTP_FFI_CONSENT_STATE_UNKNOWN = 0,
    XMTP_FFI_CONSENT_STATE_ALLOWED = 1,
    XMTP_FFI_CONSENT_STATE_DENIED = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Preference update kind."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmtpFfiPreferenceUpdateKind {
    XMTP_FFI_PREFERENCE_UPDATE_KIND_CONSENT = 0,
    XMTP_FFI_PREFERENCE_UPDATE_KIND_HMAC_KEY = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiAuthHandle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiAvailableArchiveList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiClient {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiConversation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiConversationList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiEnrichedMessageList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiGroupMemberList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiHmacKeyMap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiInboxStateList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiInboxUpdateCountList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiKeyPackageStatusList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiLastReadTimeList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiMessage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiMessageList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiSignatureRequest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpFfiStreamHandle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmtpOption_FnOnCloseCallback {
    _unused: [u8; 0],
}
#[doc = " Options for creating a client. All string fields are borrowed (not freed by this library)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiClientOptions {
    #[doc = " gRPC v3 host URL (required)."]
    pub host: *const ::core::ffi::c_char,
    #[doc = " Gateway host URL for decentralized API (nullable, enables d14n if set)."]
    pub gateway_host: *const ::core::ffi::c_char,
    #[doc = " Whether the connection is TLS-secured."]
    pub is_secure: i32,
    #[doc = " Path to the SQLite database file. Null = ephemeral."]
    pub db_path: *const ::core::ffi::c_char,
    #[doc = " 32-byte encryption key for the database. Null = unencrypted."]
    pub encryption_key: *const u8,
    #[doc = " Inbox ID (required)."]
    pub inbox_id: *const ::core::ffi::c_char,
    #[doc = " Account identifier string (required)."]
    pub account_identifier: *const ::core::ffi::c_char,
    #[doc = " Identifier kind: 0 = Ethereum, 1 = Passkey."]
    pub identifier_kind: i32,
    #[doc = " Nonce for identity strategy (default 1 if 0)."]
    pub nonce: u64,
    #[doc = " Optional auth handle for gateway authentication. Null = no auth."]
    pub auth_handle: *const XmtpFfiAuthHandle,
    #[doc = " Application version string (nullable)."]
    pub app_version: *const ::core::ffi::c_char,
    #[doc = " Device sync worker mode: 0 = Enabled (default), 1 = Disabled."]
    pub device_sync_worker_mode: i32,
    #[doc = " Allow offline mode. 0 = no (default), 1 = yes."]
    pub allow_offline: i32,
    #[doc = " Client mode: 0 = Default, 1 = Notification (read-only)."]
    pub client_mode: i32,
    #[doc = " Maximum database connection pool size. 0 = use default."]
    pub max_db_pool_size: u32,
    #[doc = " Minimum database connection pool size. 0 = use default."]
    pub min_db_pool_size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiClientOptions"][::core::mem::size_of::<XmtpFfiClientOptions>() - 112usize];
    ["Alignment of XmtpFfiClientOptions"][::core::mem::align_of::<XmtpFfiClientOptions>() - 8usize];
    ["Offset of field: XmtpFfiClientOptions::host"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, host) - 0usize];
    ["Offset of field: XmtpFfiClientOptions::gateway_host"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, gateway_host) - 8usize];
    ["Offset of field: XmtpFfiClientOptions::is_secure"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, is_secure) - 16usize];
    ["Offset of field: XmtpFfiClientOptions::db_path"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, db_path) - 24usize];
    ["Offset of field: XmtpFfiClientOptions::encryption_key"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, encryption_key) - 32usize];
    ["Offset of field: XmtpFfiClientOptions::inbox_id"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, inbox_id) - 40usize];
    ["Offset of field: XmtpFfiClientOptions::account_identifier"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, account_identifier) - 48usize];
    ["Offset of field: XmtpFfiClientOptions::identifier_kind"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, identifier_kind) - 56usize];
    ["Offset of field: XmtpFfiClientOptions::nonce"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, nonce) - 64usize];
    ["Offset of field: XmtpFfiClientOptions::auth_handle"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, auth_handle) - 72usize];
    ["Offset of field: XmtpFfiClientOptions::app_version"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, app_version) - 80usize];
    ["Offset of field: XmtpFfiClientOptions::device_sync_worker_mode"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, device_sync_worker_mode) - 88usize];
    ["Offset of field: XmtpFfiClientOptions::allow_offline"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, allow_offline) - 92usize];
    ["Offset of field: XmtpFfiClientOptions::client_mode"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, client_mode) - 96usize];
    ["Offset of field: XmtpFfiClientOptions::max_db_pool_size"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, max_db_pool_size) - 100usize];
    ["Offset of field: XmtpFfiClientOptions::min_db_pool_size"]
        [::core::mem::offset_of!(XmtpFfiClientOptions, min_db_pool_size) - 104usize];
};
impl Default for XmtpFfiClientOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " MLS API call statistics (request counts)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiApiStats {
    pub upload_key_package: i64,
    pub fetch_key_package: i64,
    pub send_group_messages: i64,
    pub send_welcome_messages: i64,
    pub query_group_messages: i64,
    pub query_welcome_messages: i64,
    pub subscribe_messages: i64,
    pub subscribe_welcomes: i64,
    pub publish_commit_log: i64,
    pub query_commit_log: i64,
    pub get_newest_group_message: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiApiStats"][::core::mem::size_of::<XmtpFfiApiStats>() - 88usize];
    ["Alignment of XmtpFfiApiStats"][::core::mem::align_of::<XmtpFfiApiStats>() - 8usize];
    ["Offset of field: XmtpFfiApiStats::upload_key_package"]
        [::core::mem::offset_of!(XmtpFfiApiStats, upload_key_package) - 0usize];
    ["Offset of field: XmtpFfiApiStats::fetch_key_package"]
        [::core::mem::offset_of!(XmtpFfiApiStats, fetch_key_package) - 8usize];
    ["Offset of field: XmtpFfiApiStats::send_group_messages"]
        [::core::mem::offset_of!(XmtpFfiApiStats, send_group_messages) - 16usize];
    ["Offset of field: XmtpFfiApiStats::send_welcome_messages"]
        [::core::mem::offset_of!(XmtpFfiApiStats, send_welcome_messages) - 24usize];
    ["Offset of field: XmtpFfiApiStats::query_group_messages"]
        [::core::mem::offset_of!(XmtpFfiApiStats, query_group_messages) - 32usize];
    ["Offset of field: XmtpFfiApiStats::query_welcome_messages"]
        [::core::mem::offset_of!(XmtpFfiApiStats, query_welcome_messages) - 40usize];
    ["Offset of field: XmtpFfiApiStats::subscribe_messages"]
        [::core::mem::offset_of!(XmtpFfiApiStats, subscribe_messages) - 48usize];
    ["Offset of field: XmtpFfiApiStats::subscribe_welcomes"]
        [::core::mem::offset_of!(XmtpFfiApiStats, subscribe_welcomes) - 56usize];
    ["Offset of field: XmtpFfiApiStats::publish_commit_log"]
        [::core::mem::offset_of!(XmtpFfiApiStats, publish_commit_log) - 64usize];
    ["Offset of field: XmtpFfiApiStats::query_commit_log"]
        [::core::mem::offset_of!(XmtpFfiApiStats, query_commit_log) - 72usize];
    ["Offset of field: XmtpFfiApiStats::get_newest_group_message"]
        [::core::mem::offset_of!(XmtpFfiApiStats, get_newest_group_message) - 80usize];
};
#[doc = " Identity API call statistics (request counts)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiIdentityStats {
    pub publish_identity_update: i64,
    pub get_identity_updates_v2: i64,
    pub get_inbox_ids: i64,
    pub verify_smart_contract_wallet_signature: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiIdentityStats"][::core::mem::size_of::<XmtpFfiIdentityStats>() - 32usize];
    ["Alignment of XmtpFfiIdentityStats"][::core::mem::align_of::<XmtpFfiIdentityStats>() - 8usize];
    ["Offset of field: XmtpFfiIdentityStats::publish_identity_update"]
        [::core::mem::offset_of!(XmtpFfiIdentityStats, publish_identity_update) - 0usize];
    ["Offset of field: XmtpFfiIdentityStats::get_identity_updates_v2"]
        [::core::mem::offset_of!(XmtpFfiIdentityStats, get_identity_updates_v2) - 8usize];
    ["Offset of field: XmtpFfiIdentityStats::get_inbox_ids"]
        [::core::mem::offset_of!(XmtpFfiIdentityStats, get_inbox_ids) - 16usize];
    ["Offset of field: XmtpFfiIdentityStats::verify_smart_contract_wallet_signature"][::core::mem::offset_of!(
        XmtpFfiIdentityStats,
        verify_smart_contract_wallet_signature
    ) - 24usize];
};
#[doc = " Inbox update count entry (inbox_id → count)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiInboxUpdateCount {
    pub inbox_id: *mut ::core::ffi::c_char,
    pub count: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiInboxUpdateCount"]
        [::core::mem::size_of::<XmtpFfiInboxUpdateCount>() - 16usize];
    ["Alignment of XmtpFfiInboxUpdateCount"]
        [::core::mem::align_of::<XmtpFfiInboxUpdateCount>() - 8usize];
    ["Offset of field: XmtpFfiInboxUpdateCount::inbox_id"]
        [::core::mem::offset_of!(XmtpFfiInboxUpdateCount, inbox_id) - 0usize];
    ["Offset of field: XmtpFfiInboxUpdateCount::count"]
        [::core::mem::offset_of!(XmtpFfiInboxUpdateCount, count) - 8usize];
};
impl Default for XmtpFfiInboxUpdateCount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Key package status for an installation."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiKeyPackageStatus {
    #[doc = " Installation ID as hex string (owned)."]
    pub installation_id: *mut ::core::ffi::c_char,
    #[doc = " 1 if valid, 0 if validation error."]
    pub valid: i32,
    #[doc = " not_before timestamp (0 if unavailable)."]
    pub not_before: u64,
    #[doc = " not_after timestamp (0 if unavailable)."]
    pub not_after: u64,
    #[doc = " Validation error message (null if no error, owned)."]
    pub validation_error: *mut ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiKeyPackageStatus"]
        [::core::mem::size_of::<XmtpFfiKeyPackageStatus>() - 40usize];
    ["Alignment of XmtpFfiKeyPackageStatus"]
        [::core::mem::align_of::<XmtpFfiKeyPackageStatus>() - 8usize];
    ["Offset of field: XmtpFfiKeyPackageStatus::installation_id"]
        [::core::mem::offset_of!(XmtpFfiKeyPackageStatus, installation_id) - 0usize];
    ["Offset of field: XmtpFfiKeyPackageStatus::valid"]
        [::core::mem::offset_of!(XmtpFfiKeyPackageStatus, valid) - 8usize];
    ["Offset of field: XmtpFfiKeyPackageStatus::not_before"]
        [::core::mem::offset_of!(XmtpFfiKeyPackageStatus, not_before) - 16usize];
    ["Offset of field: XmtpFfiKeyPackageStatus::not_after"]
        [::core::mem::offset_of!(XmtpFfiKeyPackageStatus, not_after) - 24usize];
    ["Offset of field: XmtpFfiKeyPackageStatus::validation_error"]
        [::core::mem::offset_of!(XmtpFfiKeyPackageStatus, validation_error) - 32usize];
};
impl Default for XmtpFfiKeyPackageStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Options for sending a message."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiSendOpts {
    #[doc = " Whether to send a push notification. 1 = yes (default), 0 = no."]
    pub should_push: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiSendOpts"][::core::mem::size_of::<XmtpFfiSendOpts>() - 4usize];
    ["Alignment of XmtpFfiSendOpts"][::core::mem::align_of::<XmtpFfiSendOpts>() - 4usize];
    ["Offset of field: XmtpFfiSendOpts::should_push"]
        [::core::mem::offset_of!(XmtpFfiSendOpts, should_push) - 0usize];
};
#[doc = " Options for listing messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiListMessagesOptions {
    #[doc = " Only messages sent after this timestamp (ns). 0 = no filter."]
    pub sent_after_ns: i64,
    #[doc = " Only messages sent before this timestamp (ns). 0 = no filter."]
    pub sent_before_ns: i64,
    #[doc = " Only messages inserted after this timestamp (ns). 0 = no filter."]
    pub inserted_after_ns: i64,
    #[doc = " Only messages inserted before this timestamp (ns). 0 = no filter."]
    pub inserted_before_ns: i64,
    #[doc = " Maximum number of messages. 0 = no limit."]
    pub limit: i64,
    #[doc = " Filter by delivery status: -1 = all, 0 = Unpublished, 1 = Published, 2 = Failed."]
    pub delivery_status: i32,
    #[doc = " Filter by message kind: -1 = all, 0 = Application, 1 = MembershipChange."]
    pub kind: i32,
    #[doc = " Sort direction: 0 = Ascending (default), 1 = Descending."]
    pub direction: i32,
    #[doc = " Sort by: 0 = SentAt (default), 1 = InsertedAt."]
    pub sort_by: i32,
    #[doc = " Include only these content types (nullable). Each element is a ContentType i32 value."]
    pub content_types: *const i32,
    #[doc = " Number of elements in `content_types`. 0 = no filter."]
    pub content_types_count: i32,
    #[doc = " Exclude these content types (nullable). Each element is a ContentType i32 value."]
    pub exclude_content_types: *const i32,
    #[doc = " Number of elements in `exclude_content_types`. 0 = no filter."]
    pub exclude_content_types_count: i32,
    #[doc = " Exclude messages from these sender inbox IDs (nullable C string array)."]
    pub exclude_sender_inbox_ids: *const *const ::core::ffi::c_char,
    #[doc = " Number of elements in `exclude_sender_inbox_ids`. 0 = no filter."]
    pub exclude_sender_inbox_ids_count: i32,
    #[doc = " Whether to exclude disappearing messages. 0 = include (default), 1 = exclude."]
    pub exclude_disappearing: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiListMessagesOptions"]
        [::core::mem::size_of::<XmtpFfiListMessagesOptions>() - 104usize];
    ["Alignment of XmtpFfiListMessagesOptions"]
        [::core::mem::align_of::<XmtpFfiListMessagesOptions>() - 8usize];
    ["Offset of field: XmtpFfiListMessagesOptions::sent_after_ns"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, sent_after_ns) - 0usize];
    ["Offset of field: XmtpFfiListMessagesOptions::sent_before_ns"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, sent_before_ns) - 8usize];
    ["Offset of field: XmtpFfiListMessagesOptions::inserted_after_ns"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, inserted_after_ns) - 16usize];
    ["Offset of field: XmtpFfiListMessagesOptions::inserted_before_ns"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, inserted_before_ns) - 24usize];
    ["Offset of field: XmtpFfiListMessagesOptions::limit"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, limit) - 32usize];
    ["Offset of field: XmtpFfiListMessagesOptions::delivery_status"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, delivery_status) - 40usize];
    ["Offset of field: XmtpFfiListMessagesOptions::kind"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, kind) - 44usize];
    ["Offset of field: XmtpFfiListMessagesOptions::direction"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, direction) - 48usize];
    ["Offset of field: XmtpFfiListMessagesOptions::sort_by"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, sort_by) - 52usize];
    ["Offset of field: XmtpFfiListMessagesOptions::content_types"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, content_types) - 56usize];
    ["Offset of field: XmtpFfiListMessagesOptions::content_types_count"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, content_types_count) - 64usize];
    ["Offset of field: XmtpFfiListMessagesOptions::exclude_content_types"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, exclude_content_types) - 72usize];
    ["Offset of field: XmtpFfiListMessagesOptions::exclude_content_types_count"][::core::mem::offset_of!(
        XmtpFfiListMessagesOptions,
        exclude_content_types_count
    ) - 80usize];
    ["Offset of field: XmtpFfiListMessagesOptions::exclude_sender_inbox_ids"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, exclude_sender_inbox_ids) - 88usize];
    ["Offset of field: XmtpFfiListMessagesOptions::exclude_sender_inbox_ids_count"][::core::mem::offset_of!(
        XmtpFfiListMessagesOptions,
        exclude_sender_inbox_ids_count
    ) - 96usize];
    ["Offset of field: XmtpFfiListMessagesOptions::exclude_disappearing"]
        [::core::mem::offset_of!(XmtpFfiListMessagesOptions, exclude_disappearing) - 100usize];
};
impl Default for XmtpFfiListMessagesOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Options for message disappearing settings."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiDisappearingSettings {
    #[doc = " Timestamp (ns) from which messages start disappearing."]
    pub from_ns: i64,
    #[doc = " Duration (ns) after which messages disappear."]
    pub in_ns: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiDisappearingSettings"]
        [::core::mem::size_of::<XmtpFfiDisappearingSettings>() - 16usize];
    ["Alignment of XmtpFfiDisappearingSettings"]
        [::core::mem::align_of::<XmtpFfiDisappearingSettings>() - 8usize];
    ["Offset of field: XmtpFfiDisappearingSettings::from_ns"]
        [::core::mem::offset_of!(XmtpFfiDisappearingSettings, from_ns) - 0usize];
    ["Offset of field: XmtpFfiDisappearingSettings::in_ns"]
        [::core::mem::offset_of!(XmtpFfiDisappearingSettings, in_ns) - 8usize];
};
#[doc = " A single cursor entry (originator + sequence)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiCursor {
    pub originator_id: u32,
    pub sequence_id: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiCursor"][::core::mem::size_of::<XmtpFfiCursor>() - 16usize];
    ["Alignment of XmtpFfiCursor"][::core::mem::align_of::<XmtpFfiCursor>() - 8usize];
    ["Offset of field: XmtpFfiCursor::originator_id"]
        [::core::mem::offset_of!(XmtpFfiCursor, originator_id) - 0usize];
    ["Offset of field: XmtpFfiCursor::sequence_id"]
        [::core::mem::offset_of!(XmtpFfiCursor, sequence_id) - 8usize];
};
#[doc = " Conversation debug info (epoch, fork status, commit logs, cursors)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiConversationDebugInfo {
    pub epoch: u64,
    pub maybe_forked: i32,
    pub fork_details: *mut ::core::ffi::c_char,
    #[doc = " -1 = unknown, 0 = no, 1 = yes"]
    pub is_commit_log_forked: i32,
    pub local_commit_log: *mut ::core::ffi::c_char,
    pub remote_commit_log: *mut ::core::ffi::c_char,
    #[doc = " Heap-allocated cursor array. Free with the debug_info_free function."]
    pub cursors: *mut XmtpFfiCursor,
    pub cursors_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiConversationDebugInfo"]
        [::core::mem::size_of::<XmtpFfiConversationDebugInfo>() - 64usize];
    ["Alignment of XmtpFfiConversationDebugInfo"]
        [::core::mem::align_of::<XmtpFfiConversationDebugInfo>() - 8usize];
    ["Offset of field: XmtpFfiConversationDebugInfo::epoch"]
        [::core::mem::offset_of!(XmtpFfiConversationDebugInfo, epoch) - 0usize];
    ["Offset of field: XmtpFfiConversationDebugInfo::maybe_forked"]
        [::core::mem::offset_of!(XmtpFfiConversationDebugInfo, maybe_forked) - 8usize];
    ["Offset of field: XmtpFfiConversationDebugInfo::fork_details"]
        [::core::mem::offset_of!(XmtpFfiConversationDebugInfo, fork_details) - 16usize];
    ["Offset of field: XmtpFfiConversationDebugInfo::is_commit_log_forked"]
        [::core::mem::offset_of!(XmtpFfiConversationDebugInfo, is_commit_log_forked) - 24usize];
    ["Offset of field: XmtpFfiConversationDebugInfo::local_commit_log"]
        [::core::mem::offset_of!(XmtpFfiConversationDebugInfo, local_commit_log) - 32usize];
    ["Offset of field: XmtpFfiConversationDebugInfo::remote_commit_log"]
        [::core::mem::offset_of!(XmtpFfiConversationDebugInfo, remote_commit_log) - 40usize];
    ["Offset of field: XmtpFfiConversationDebugInfo::cursors"]
        [::core::mem::offset_of!(XmtpFfiConversationDebugInfo, cursors) - 48usize];
    ["Offset of field: XmtpFfiConversationDebugInfo::cursors_count"]
        [::core::mem::offset_of!(XmtpFfiConversationDebugInfo, cursors_count) - 56usize];
};
impl Default for XmtpFfiConversationDebugInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A single HMAC key (42-byte key + epoch)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiHmacKey {
    pub key: *mut u8,
    pub key_len: i32,
    pub epoch: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiHmacKey"][::core::mem::size_of::<XmtpFfiHmacKey>() - 24usize];
    ["Alignment of XmtpFfiHmacKey"][::core::mem::align_of::<XmtpFfiHmacKey>() - 8usize];
    ["Offset of field: XmtpFfiHmacKey::key"][::core::mem::offset_of!(XmtpFfiHmacKey, key) - 0usize];
    ["Offset of field: XmtpFfiHmacKey::key_len"]
        [::core::mem::offset_of!(XmtpFfiHmacKey, key_len) - 8usize];
    ["Offset of field: XmtpFfiHmacKey::epoch"]
        [::core::mem::offset_of!(XmtpFfiHmacKey, epoch) - 16usize];
};
impl Default for XmtpFfiHmacKey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Group metadata (creator + conversation type)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiGroupMetadata {
    #[doc = " Creator inbox ID (owned string)."]
    pub creator_inbox_id: *mut ::core::ffi::c_char,
    pub conversation_type: XmtpFfiConversationType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiGroupMetadata"][::core::mem::size_of::<XmtpFfiGroupMetadata>() - 16usize];
    ["Alignment of XmtpFfiGroupMetadata"][::core::mem::align_of::<XmtpFfiGroupMetadata>() - 8usize];
    ["Offset of field: XmtpFfiGroupMetadata::creator_inbox_id"]
        [::core::mem::offset_of!(XmtpFfiGroupMetadata, creator_inbox_id) - 0usize];
    ["Offset of field: XmtpFfiGroupMetadata::conversation_type"]
        [::core::mem::offset_of!(XmtpFfiGroupMetadata, conversation_type) - 8usize];
};
impl Default for XmtpFfiGroupMetadata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Permission policy set for a conversation."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiPermissionPolicySet {
    pub add_member_policy: XmtpFfiPermissionPolicy,
    pub remove_member_policy: XmtpFfiPermissionPolicy,
    pub add_admin_policy: XmtpFfiPermissionPolicy,
    pub remove_admin_policy: XmtpFfiPermissionPolicy,
    pub update_group_name_policy: XmtpFfiPermissionPolicy,
    pub update_group_description_policy: XmtpFfiPermissionPolicy,
    pub update_group_image_url_square_policy: XmtpFfiPermissionPolicy,
    pub update_message_disappearing_policy: XmtpFfiPermissionPolicy,
    pub update_app_data_policy: XmtpFfiPermissionPolicy,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiPermissionPolicySet"]
        [::core::mem::size_of::<XmtpFfiPermissionPolicySet>() - 36usize];
    ["Alignment of XmtpFfiPermissionPolicySet"]
        [::core::mem::align_of::<XmtpFfiPermissionPolicySet>() - 4usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::add_member_policy"]
        [::core::mem::offset_of!(XmtpFfiPermissionPolicySet, add_member_policy) - 0usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::remove_member_policy"]
        [::core::mem::offset_of!(XmtpFfiPermissionPolicySet, remove_member_policy) - 4usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::add_admin_policy"]
        [::core::mem::offset_of!(XmtpFfiPermissionPolicySet, add_admin_policy) - 8usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::remove_admin_policy"]
        [::core::mem::offset_of!(XmtpFfiPermissionPolicySet, remove_admin_policy) - 12usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::update_group_name_policy"]
        [::core::mem::offset_of!(XmtpFfiPermissionPolicySet, update_group_name_policy) - 16usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::update_group_description_policy"][::core::mem::offset_of!(
        XmtpFfiPermissionPolicySet,
        update_group_description_policy
    ) - 20usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::update_group_image_url_square_policy"][::core::mem::offset_of!(
        XmtpFfiPermissionPolicySet,
        update_group_image_url_square_policy
    )
        - 24usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::update_message_disappearing_policy"][::core::mem::offset_of!(
        XmtpFfiPermissionPolicySet,
        update_message_disappearing_policy
    )
        - 28usize];
    ["Offset of field: XmtpFfiPermissionPolicySet::update_app_data_policy"]
        [::core::mem::offset_of!(XmtpFfiPermissionPolicySet, update_app_data_policy) - 32usize];
};
impl Default for XmtpFfiPermissionPolicySet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Group permissions (policy type + policy set)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiGroupPermissions {
    pub policy_type: XmtpFfiGroupPermissionsPreset,
    pub policy_set: XmtpFfiPermissionPolicySet,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiGroupPermissions"]
        [::core::mem::size_of::<XmtpFfiGroupPermissions>() - 40usize];
    ["Alignment of XmtpFfiGroupPermissions"]
        [::core::mem::align_of::<XmtpFfiGroupPermissions>() - 4usize];
    ["Offset of field: XmtpFfiGroupPermissions::policy_type"]
        [::core::mem::offset_of!(XmtpFfiGroupPermissions, policy_type) - 0usize];
    ["Offset of field: XmtpFfiGroupPermissions::policy_set"]
        [::core::mem::offset_of!(XmtpFfiGroupPermissions, policy_set) - 4usize];
};
impl Default for XmtpFfiGroupPermissions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An enriched (decoded) message exposed to C.\n Contains metadata + the original encoded content bytes for upper-layer decoding."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiEnrichedMessage {
    #[doc = " Message ID (hex string, owned)."]
    pub id: *mut ::core::ffi::c_char,
    #[doc = " Group ID (hex string, owned)."]
    pub group_id: *mut ::core::ffi::c_char,
    #[doc = " Sender inbox ID (owned string)."]
    pub sender_inbox_id: *mut ::core::ffi::c_char,
    #[doc = " Sender installation ID (hex string, owned)."]
    pub sender_installation_id: *mut ::core::ffi::c_char,
    #[doc = " Sent timestamp in nanoseconds."]
    pub sent_at_ns: i64,
    #[doc = " Inserted-into-DB timestamp in nanoseconds."]
    pub inserted_at_ns: i64,
    pub kind: XmtpFfiMessageKind,
    pub delivery_status: XmtpFfiDeliveryStatus,
    #[doc = " Content type ID string (e.g. \"xmtp.org/text:1.0\", owned)."]
    pub content_type: *mut ::core::ffi::c_char,
    #[doc = " Fallback text (nullable, owned)."]
    pub fallback_text: *mut ::core::ffi::c_char,
    #[doc = " Expiration timestamp in nanoseconds (0 = no expiration)."]
    pub expires_at_ns: i64,
    #[doc = " Number of reactions."]
    pub num_reactions: i32,
    #[doc = " Number of replies."]
    pub num_replies: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiEnrichedMessage"][::core::mem::size_of::<XmtpFfiEnrichedMessage>() - 88usize];
    ["Alignment of XmtpFfiEnrichedMessage"]
        [::core::mem::align_of::<XmtpFfiEnrichedMessage>() - 8usize];
    ["Offset of field: XmtpFfiEnrichedMessage::id"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, id) - 0usize];
    ["Offset of field: XmtpFfiEnrichedMessage::group_id"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, group_id) - 8usize];
    ["Offset of field: XmtpFfiEnrichedMessage::sender_inbox_id"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, sender_inbox_id) - 16usize];
    ["Offset of field: XmtpFfiEnrichedMessage::sender_installation_id"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, sender_installation_id) - 24usize];
    ["Offset of field: XmtpFfiEnrichedMessage::sent_at_ns"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, sent_at_ns) - 32usize];
    ["Offset of field: XmtpFfiEnrichedMessage::inserted_at_ns"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, inserted_at_ns) - 40usize];
    ["Offset of field: XmtpFfiEnrichedMessage::kind"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, kind) - 48usize];
    ["Offset of field: XmtpFfiEnrichedMessage::delivery_status"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, delivery_status) - 52usize];
    ["Offset of field: XmtpFfiEnrichedMessage::content_type"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, content_type) - 56usize];
    ["Offset of field: XmtpFfiEnrichedMessage::fallback_text"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, fallback_text) - 64usize];
    ["Offset of field: XmtpFfiEnrichedMessage::expires_at_ns"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, expires_at_ns) - 72usize];
    ["Offset of field: XmtpFfiEnrichedMessage::num_reactions"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, num_reactions) - 80usize];
    ["Offset of field: XmtpFfiEnrichedMessage::num_replies"]
        [::core::mem::offset_of!(XmtpFfiEnrichedMessage, num_replies) - 84usize];
};
impl Default for XmtpFfiEnrichedMessage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Last-read-time entry (inbox_id → timestamp_ns)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiLastReadTimeEntry {
    pub inbox_id: *mut ::core::ffi::c_char,
    pub timestamp_ns: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiLastReadTimeEntry"]
        [::core::mem::size_of::<XmtpFfiLastReadTimeEntry>() - 16usize];
    ["Alignment of XmtpFfiLastReadTimeEntry"]
        [::core::mem::align_of::<XmtpFfiLastReadTimeEntry>() - 8usize];
    ["Offset of field: XmtpFfiLastReadTimeEntry::inbox_id"]
        [::core::mem::offset_of!(XmtpFfiLastReadTimeEntry, inbox_id) - 0usize];
    ["Offset of field: XmtpFfiLastReadTimeEntry::timestamp_ns"]
        [::core::mem::offset_of!(XmtpFfiLastReadTimeEntry, timestamp_ns) - 8usize];
};
impl Default for XmtpFfiLastReadTimeEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Options for creating a new group conversation."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiCreateGroupOptions {
    #[doc = " Permission preset: 0 = AllMembers (default), 1 = AdminOnly."]
    pub permissions: i32,
    #[doc = " Group name (nullable)."]
    pub name: *const ::core::ffi::c_char,
    #[doc = " Group description (nullable)."]
    pub description: *const ::core::ffi::c_char,
    #[doc = " Group image URL (nullable)."]
    pub image_url: *const ::core::ffi::c_char,
    #[doc = " Custom app data string (nullable)."]
    pub app_data: *const ::core::ffi::c_char,
    #[doc = " Message disappearing \"from\" timestamp in ns. 0 = not set."]
    pub message_disappear_from_ns: i64,
    #[doc = " Message disappearing \"in\" duration in ns. 0 = not set."]
    pub message_disappear_in_ns: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiCreateGroupOptions"]
        [::core::mem::size_of::<XmtpFfiCreateGroupOptions>() - 56usize];
    ["Alignment of XmtpFfiCreateGroupOptions"]
        [::core::mem::align_of::<XmtpFfiCreateGroupOptions>() - 8usize];
    ["Offset of field: XmtpFfiCreateGroupOptions::permissions"]
        [::core::mem::offset_of!(XmtpFfiCreateGroupOptions, permissions) - 0usize];
    ["Offset of field: XmtpFfiCreateGroupOptions::name"]
        [::core::mem::offset_of!(XmtpFfiCreateGroupOptions, name) - 8usize];
    ["Offset of field: XmtpFfiCreateGroupOptions::description"]
        [::core::mem::offset_of!(XmtpFfiCreateGroupOptions, description) - 16usize];
    ["Offset of field: XmtpFfiCreateGroupOptions::image_url"]
        [::core::mem::offset_of!(XmtpFfiCreateGroupOptions, image_url) - 24usize];
    ["Offset of field: XmtpFfiCreateGroupOptions::app_data"]
        [::core::mem::offset_of!(XmtpFfiCreateGroupOptions, app_data) - 32usize];
    ["Offset of field: XmtpFfiCreateGroupOptions::message_disappear_from_ns"]
        [::core::mem::offset_of!(XmtpFfiCreateGroupOptions, message_disappear_from_ns) - 40usize];
    ["Offset of field: XmtpFfiCreateGroupOptions::message_disappear_in_ns"]
        [::core::mem::offset_of!(XmtpFfiCreateGroupOptions, message_disappear_in_ns) - 48usize];
};
impl Default for XmtpFfiCreateGroupOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Options for listing conversations."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiListConversationsOptions {
    #[doc = " Conversation type filter: -1 = all, 0 = DM, 1 = Group."]
    pub conversation_type: i32,
    #[doc = " Maximum number of conversations to return. 0 = no limit."]
    pub limit: i64,
    #[doc = " Only include conversations created after this timestamp (ns). 0 = no filter."]
    pub created_after_ns: i64,
    #[doc = " Only include conversations created before this timestamp (ns). 0 = no filter."]
    pub created_before_ns: i64,
    #[doc = " Only include conversations with last activity after this timestamp (ns). 0 = no filter."]
    pub last_activity_after_ns: i64,
    #[doc = " Only include conversations with last activity before this timestamp (ns). 0 = no filter."]
    pub last_activity_before_ns: i64,
    #[doc = " Consent state filter (parallel array with `consent_states_count`).\n Values: 0 = Unknown, 1 = Allowed, 2 = Denied."]
    pub consent_states: *const i32,
    #[doc = " Number of consent states in the filter. 0 = no filter."]
    pub consent_states_count: i32,
    #[doc = " Order by: 0 = CreatedAt (default), 1 = LastActivity."]
    pub order_by: i32,
    #[doc = " Whether to include duplicate DMs. 0 = no (default), 1 = yes."]
    pub include_duplicate_dms: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiListConversationsOptions"]
        [::core::mem::size_of::<XmtpFfiListConversationsOptions>() - 72usize];
    ["Alignment of XmtpFfiListConversationsOptions"]
        [::core::mem::align_of::<XmtpFfiListConversationsOptions>() - 8usize];
    ["Offset of field: XmtpFfiListConversationsOptions::conversation_type"]
        [::core::mem::offset_of!(XmtpFfiListConversationsOptions, conversation_type) - 0usize];
    ["Offset of field: XmtpFfiListConversationsOptions::limit"]
        [::core::mem::offset_of!(XmtpFfiListConversationsOptions, limit) - 8usize];
    ["Offset of field: XmtpFfiListConversationsOptions::created_after_ns"]
        [::core::mem::offset_of!(XmtpFfiListConversationsOptions, created_after_ns) - 16usize];
    ["Offset of field: XmtpFfiListConversationsOptions::created_before_ns"]
        [::core::mem::offset_of!(XmtpFfiListConversationsOptions, created_before_ns) - 24usize];
    ["Offset of field: XmtpFfiListConversationsOptions::last_activity_after_ns"][::core::mem::offset_of!(
        XmtpFfiListConversationsOptions,
        last_activity_after_ns
    ) - 32usize];
    ["Offset of field: XmtpFfiListConversationsOptions::last_activity_before_ns"][::core::mem::offset_of!(
        XmtpFfiListConversationsOptions,
        last_activity_before_ns
    ) - 40usize];
    ["Offset of field: XmtpFfiListConversationsOptions::consent_states"]
        [::core::mem::offset_of!(XmtpFfiListConversationsOptions, consent_states) - 48usize];
    ["Offset of field: XmtpFfiListConversationsOptions::consent_states_count"]
        [::core::mem::offset_of!(XmtpFfiListConversationsOptions, consent_states_count) - 56usize];
    ["Offset of field: XmtpFfiListConversationsOptions::order_by"]
        [::core::mem::offset_of!(XmtpFfiListConversationsOptions, order_by) - 60usize];
    ["Offset of field: XmtpFfiListConversationsOptions::include_duplicate_dms"]
        [::core::mem::offset_of!(XmtpFfiListConversationsOptions, include_duplicate_dms) - 64usize];
};
impl Default for XmtpFfiListConversationsOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Options for device sync archive operations."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiArchiveOptions {
    #[doc = " Bitmask of element selections: bit 0 = Messages, bit 1 = Consent."]
    pub elements: i32,
    #[doc = " Start timestamp filter (ns). 0 = no filter."]
    pub start_ns: i64,
    #[doc = " End timestamp filter (ns). 0 = no filter."]
    pub end_ns: i64,
    #[doc = " Whether to exclude disappearing messages. 0 = include, 1 = exclude."]
    pub exclude_disappearing_messages: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiArchiveOptions"][::core::mem::size_of::<XmtpFfiArchiveOptions>() - 32usize];
    ["Alignment of XmtpFfiArchiveOptions"]
        [::core::mem::align_of::<XmtpFfiArchiveOptions>() - 8usize];
    ["Offset of field: XmtpFfiArchiveOptions::elements"]
        [::core::mem::offset_of!(XmtpFfiArchiveOptions, elements) - 0usize];
    ["Offset of field: XmtpFfiArchiveOptions::start_ns"]
        [::core::mem::offset_of!(XmtpFfiArchiveOptions, start_ns) - 8usize];
    ["Offset of field: XmtpFfiArchiveOptions::end_ns"]
        [::core::mem::offset_of!(XmtpFfiArchiveOptions, end_ns) - 16usize];
    ["Offset of field: XmtpFfiArchiveOptions::exclude_disappearing_messages"]
        [::core::mem::offset_of!(XmtpFfiArchiveOptions, exclude_disappearing_messages) - 24usize];
};
#[doc = " Callback for conversation stream events."]
pub type XmtpFnConversationCallback = ::core::option::Option<
    unsafe extern "C" fn(conversation: *mut XmtpFfiConversation, context: *mut ::core::ffi::c_void),
>;
#[doc = " Callback for message stream events."]
pub type XmtpFnMessageCallback = ::core::option::Option<
    unsafe extern "C" fn(message: *mut XmtpFfiMessage, context: *mut ::core::ffi::c_void),
>;
#[doc = " A consent record exposed to C."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiConsentRecord {
    pub entity_type: XmtpFfiConsentEntityType,
    pub state: XmtpFfiConsentState,
    #[doc = " Entity identifier string."]
    pub entity: *mut ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiConsentRecord"][::core::mem::size_of::<XmtpFfiConsentRecord>() - 16usize];
    ["Alignment of XmtpFfiConsentRecord"][::core::mem::align_of::<XmtpFfiConsentRecord>() - 8usize];
    ["Offset of field: XmtpFfiConsentRecord::entity_type"]
        [::core::mem::offset_of!(XmtpFfiConsentRecord, entity_type) - 0usize];
    ["Offset of field: XmtpFfiConsentRecord::state"]
        [::core::mem::offset_of!(XmtpFfiConsentRecord, state) - 4usize];
    ["Offset of field: XmtpFfiConsentRecord::entity"]
        [::core::mem::offset_of!(XmtpFfiConsentRecord, entity) - 8usize];
};
impl Default for XmtpFfiConsentRecord {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback for consent stream events.\n `records` is borrowed — valid only during the callback invocation."]
pub type XmtpFnConsentCallback = ::core::option::Option<
    unsafe extern "C" fn(
        records: *const XmtpFfiConsentRecord,
        count: i32,
        context: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " A preference update exposed to C."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct XmtpFfiPreferenceUpdate {
    pub kind: XmtpFfiPreferenceUpdateKind,
    #[doc = " For Consent: the consent record. For HmacKey: zeroed."]
    pub consent: XmtpFfiConsentRecord,
    #[doc = " For HmacKey: the key bytes. For Consent: null/0."]
    pub hmac_key: *mut u8,
    pub hmac_key_len: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XmtpFfiPreferenceUpdate"]
        [::core::mem::size_of::<XmtpFfiPreferenceUpdate>() - 40usize];
    ["Alignment of XmtpFfiPreferenceUpdate"]
        [::core::mem::align_of::<XmtpFfiPreferenceUpdate>() - 8usize];
    ["Offset of field: XmtpFfiPreferenceUpdate::kind"]
        [::core::mem::offset_of!(XmtpFfiPreferenceUpdate, kind) - 0usize];
    ["Offset of field: XmtpFfiPreferenceUpdate::consent"]
        [::core::mem::offset_of!(XmtpFfiPreferenceUpdate, consent) - 8usize];
    ["Offset of field: XmtpFfiPreferenceUpdate::hmac_key"]
        [::core::mem::offset_of!(XmtpFfiPreferenceUpdate, hmac_key) - 24usize];
    ["Offset of field: XmtpFfiPreferenceUpdate::hmac_key_len"]
        [::core::mem::offset_of!(XmtpFfiPreferenceUpdate, hmac_key_len) - 32usize];
};
impl Default for XmtpFfiPreferenceUpdate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback for preference stream events.\n `updates` is borrowed — valid only during the callback invocation."]
pub type XmtpFnPreferenceCallback = ::core::option::Option<
    unsafe extern "C" fn(
        updates: *const XmtpFfiPreferenceUpdate,
        count: i32,
        context: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Callback for message deletion stream events.\n `message_id` is a borrowed hex string — valid only during the callback."]
pub type XmtpFnMessageDeletionCallback = ::core::option::Option<
    unsafe extern "C" fn(message_id: *const ::core::ffi::c_char, context: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = " Get the length of the last error message (including NUL terminator).\n Returns 0 if no error."]
    pub fn xmtp_last_error_length() -> i32;
}
unsafe extern "C" {
    #[doc = " Copy the last error message into `buf`. Returns bytes written (excluding NUL),\n or -1 if `buf` is null or too small."]
    pub fn xmtp_last_error_message(buf: *mut ::core::ffi::c_char, buf_len: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " Free a string previously returned by this library."]
    pub fn xmtp_free_string(s: *mut ::core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = " Free a byte buffer previously returned by this library."]
    pub fn xmtp_free_bytes(ptr: *mut u8, len: i32);
}
unsafe extern "C" {
    #[doc = " Free a string array returned by this library."]
    pub fn xmtp_free_string_array(arr: *mut *mut ::core::ffi::c_char, count: i32);
}
unsafe extern "C" {
    #[doc = " Initialize the tracing logger. Call at most once. `level` is a C string like\n \"debug\", \"info\", \"warn\", \"error\", or \"off\". Pass null for default (\"info\").\n Returns 0 on success."]
    pub fn xmtp_init_logger(level: *const ::core::ffi::c_char) -> i32;
}
unsafe extern "C" {
    #[doc = " Create a new XMTP client. Caller must free with [`xmtp_client_free`]."]
    pub fn xmtp_client_create(
        opts: *const XmtpFfiClientOptions,
        out: *mut *mut XmtpFfiClient,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_client_free(ptr: *mut XmtpFfiClient);
}
unsafe extern "C" {
    #[doc = " Get the client's inbox ID. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_client_inbox_id(client: *const XmtpFfiClient) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the client's installation ID (hex). Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_client_installation_id(client: *const XmtpFfiClient) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Check if the client identity is registered. Returns 1 = yes, 0 = no, -1 = error."]
    pub fn xmtp_client_is_registered(client: *const XmtpFfiClient) -> i32;
}
unsafe extern "C" {
    #[doc = " Register the client identity with an optional signature request.\n Pass null for `sig_req` if no external signature is needed."]
    pub fn xmtp_client_register_identity(
        client: *const XmtpFfiClient,
        sig_req: *const XmtpFfiSignatureRequest,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Check which identifiers can receive messages.\n `identifiers` is an array of C strings, `kinds` is a parallel array of identifier kinds.\n Results are written to `out_results` (1 = can message, 0 = cannot)."]
    pub fn xmtp_client_can_message(
        client: *const XmtpFfiClient,
        identifiers: *const *const ::core::ffi::c_char,
        kinds: *const i32,
        count: i32,
        out_results: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Release the database connection pool."]
    pub fn xmtp_client_release_db_connection(client: *const XmtpFfiClient) -> i32;
}
unsafe extern "C" {
    #[doc = " Reconnect to the database."]
    pub fn xmtp_client_reconnect_db(client: *const XmtpFfiClient) -> i32;
}
unsafe extern "C" {
    #[doc = " Set consent states for multiple entities.\n `entity_types`: 0 = GroupId, 1 = InboxId.\n `states`: 0 = Unknown, 1 = Allowed, 2 = Denied."]
    pub fn xmtp_client_set_consent_states(
        client: *const XmtpFfiClient,
        entity_types: *const i32,
        states: *const i32,
        entities: *const *const ::core::ffi::c_char,
        count: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get consent state for a single entity. Result written to `out_state`."]
    pub fn xmtp_client_get_consent_state(
        client: *const XmtpFfiClient,
        entity_type: i32,
        entity: *const ::core::ffi::c_char,
        out_state: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the inbox state for this client as a single-element list.\n Caller must free with [`xmtp_inbox_state_list_free`]."]
    pub fn xmtp_client_inbox_state(
        client: *const XmtpFfiClient,
        refresh: i32,
        out: *mut *mut XmtpFfiInboxStateList,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the client's installation ID as raw bytes.\n Writes length to `out_len`. Caller must free with [`xmtp_free_bytes`]."]
    pub fn xmtp_client_installation_id_bytes(
        client: *const XmtpFfiClient,
        out_len: *mut i32,
    ) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " Verify a signature produced by `xmtp_client_sign_with_installation_key`.\n Returns 0 on success (valid), -1 on error (invalid or bad args)."]
    pub fn xmtp_client_verify_signed_with_installation_key(
        client: *const XmtpFfiClient,
        text: *const ::core::ffi::c_char,
        signature_bytes: *const u8,
        signature_len: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get a message by its hex-encoded ID. Caller must free with [`xmtp_message_free`]."]
    pub fn xmtp_client_get_message_by_id(
        client: *const XmtpFfiClient,
        message_id_hex: *const ::core::ffi::c_char,
        out: *mut *mut XmtpFfiMessage,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Delete a message by its hex-encoded ID. Returns the number of deleted rows."]
    pub fn xmtp_client_delete_message_by_id(
        client: *const XmtpFfiClient,
        message_id_hex: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the libxmtp version string. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_libxmtp_version() -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get MLS API call statistics. Writes to `out`."]
    pub fn xmtp_client_api_statistics(
        client: *const XmtpFfiClient,
        out: *mut XmtpFfiApiStats,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get identity API call statistics. Writes to `out`."]
    pub fn xmtp_client_api_identity_statistics(
        client: *const XmtpFfiClient,
        out: *mut XmtpFfiIdentityStats,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get aggregate statistics as a debug string. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_client_api_aggregate_statistics(
        client: *const XmtpFfiClient,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Clear all API call statistics."]
    pub fn xmtp_client_clear_all_statistics(client: *const XmtpFfiClient) -> i32;
}
unsafe extern "C" {
    #[doc = " Look up an inbox ID by account identifier using the client's connection.\n `identifier_kind`: 0 = Ethereum, 1 = Passkey.\n Returns null if not found. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_client_get_inbox_id_by_identifier(
        client: *const XmtpFfiClient,
        identifier: *const ::core::ffi::c_char,
        identifier_kind: i32,
        out: *mut *mut ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Fetch inbox states for multiple inbox IDs.\n `inbox_ids` is a null-terminated array of C strings with `count` elements.\n Returns an opaque `FfiInboxStateList` via `out`. Caller must free with [`xmtp_inbox_state_list_free`]."]
    pub fn xmtp_client_fetch_inbox_states(
        client: *const XmtpFfiClient,
        inbox_ids: *const *const ::core::ffi::c_char,
        count: i32,
        refresh_from_network: i32,
        out: *mut *mut XmtpFfiInboxStateList,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_inbox_state_list_len(list: *const XmtpFfiInboxStateList) -> i32;
}
unsafe extern "C" {
    #[doc = " Get inbox ID at index. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_inbox_state_inbox_id(
        list: *const XmtpFfiInboxStateList,
        index: i32,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get recovery identifier at index. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_inbox_state_recovery_identifier(
        list: *const XmtpFfiInboxStateList,
        index: i32,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get identifiers array at index. Returns a borrowed pointer; do NOT free."]
    pub fn xmtp_inbox_state_identifiers(
        list: *const XmtpFfiInboxStateList,
        index: i32,
        out_count: *mut i32,
    ) -> *const *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get installation IDs (hex) at index. Returns a borrowed pointer; do NOT free."]
    pub fn xmtp_inbox_state_installation_ids(
        list: *const XmtpFfiInboxStateList,
        index: i32,
        out_count: *mut i32,
    ) -> *const *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Free an inbox state list."]
    pub fn xmtp_inbox_state_list_free(list: *mut XmtpFfiInboxStateList);
}
unsafe extern "C" {
    #[doc = " Create a new gateway auth handle. Caller must free with [`xmtp_auth_handle_free`]."]
    pub fn xmtp_auth_handle_create(out: *mut *mut XmtpFfiAuthHandle) -> i32;
}
unsafe extern "C" {
    #[doc = " Set a credential on an auth handle.\n `name` is an optional HTTP header name (null = \"authorization\").\n `value` is the header value (required).\n `expires_at_seconds` is the Unix timestamp when the credential expires."]
    pub fn xmtp_auth_handle_set(
        handle: *const XmtpFfiAuthHandle,
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
        expires_at_seconds: i64,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the unique ID of an auth handle."]
    pub fn xmtp_auth_handle_id(handle: *const XmtpFfiAuthHandle) -> usize;
}
unsafe extern "C" {
    pub fn xmtp_auth_handle_free(ptr: *mut XmtpFfiAuthHandle);
}
unsafe extern "C" {
    #[doc = " Fetch the number of identity updates for multiple inbox IDs.\n Caller must free the result with [`xmtp_inbox_update_count_list_free`]."]
    pub fn xmtp_client_fetch_inbox_updates_count(
        client: *const XmtpFfiClient,
        inbox_ids: *const *const ::core::ffi::c_char,
        inbox_ids_count: i32,
        refresh: i32,
        out: *mut *mut XmtpFfiInboxUpdateCountList,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Fetch the number of identity updates for the client's own inbox."]
    pub fn xmtp_client_fetch_own_inbox_updates_count(
        client: *const XmtpFfiClient,
        refresh: i32,
        out: *mut u32,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_inbox_update_count_list_len(list: *const XmtpFfiInboxUpdateCountList) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_inbox_update_count_list_get(
        list: *const XmtpFfiInboxUpdateCountList,
        index: i32,
    ) -> *const XmtpFfiInboxUpdateCount;
}
unsafe extern "C" {
    #[doc = " Free an inbox update count list."]
    pub fn xmtp_inbox_update_count_list_free(list: *mut XmtpFfiInboxUpdateCountList);
}
unsafe extern "C" {
    #[doc = " Fetch key package statuses for a list of installation IDs (hex-encoded).\n Caller must free with [`xmtp_key_package_status_list_free`]."]
    pub fn xmtp_client_fetch_key_package_statuses(
        client: *const XmtpFfiClient,
        installation_ids: *const *const ::core::ffi::c_char,
        installation_ids_count: i32,
        out: *mut *mut XmtpFfiKeyPackageStatusList,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_key_package_status_list_len(list: *const XmtpFfiKeyPackageStatusList) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_key_package_status_list_get(
        list: *const XmtpFfiKeyPackageStatusList,
        index: i32,
    ) -> *const XmtpFfiKeyPackageStatus;
}
unsafe extern "C" {
    #[doc = " Free a key package status list."]
    pub fn xmtp_key_package_status_list_free(list: *mut XmtpFfiKeyPackageStatusList);
}
unsafe extern "C" {
    #[doc = " Get the account identifier string used to create this client.\n Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_client_account_identifier(client: *const XmtpFfiClient)
    -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the app version string set during client creation.\n Returns null if no app version was set. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_client_app_version(client: *const XmtpFfiClient) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xmtp_conversation_free(ptr: *mut XmtpFfiConversation);
}
unsafe extern "C" {
    #[doc = " Get the conversation's hex-encoded group ID. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_conversation_id(conv: *const XmtpFfiConversation) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the conversation created-at timestamp in nanoseconds."]
    pub fn xmtp_conversation_created_at_ns(conv: *const XmtpFfiConversation) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the conversation type. Returns `FfiConversationType` value, or -1 on error."]
    pub fn xmtp_conversation_type(conv: *const XmtpFfiConversation) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the DM peer's inbox ID. Caller must free with [`xmtp_free_string`].\n Returns null if not a DM or on error."]
    pub fn xmtp_conversation_dm_peer_inbox_id(
        conv: *const XmtpFfiConversation,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Sync this conversation with the network."]
    pub fn xmtp_conversation_sync(conv: *const XmtpFfiConversation) -> i32;
}
unsafe extern "C" {
    #[doc = " Send raw encoded content bytes. Returns the message ID (hex) via `out_id`.\n Caller must free `out_id` with [`xmtp_free_string`].\n Pass null for `opts` to use defaults (should_push = true)."]
    pub fn xmtp_conversation_send(
        conv: *const XmtpFfiConversation,
        content_bytes: *const u8,
        content_len: i32,
        opts: *const XmtpFfiSendOpts,
        out_id: *mut *mut ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Send raw encoded content bytes optimistically (returns immediately, publishes in background).\n Returns the message ID (hex) via `out_id`. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_conversation_send_optimistic(
        conv: *const XmtpFfiConversation,
        content_bytes: *const u8,
        content_len: i32,
        opts: *const XmtpFfiSendOpts,
        out_id: *mut *mut ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Publish all queued (unpublished) messages in this conversation."]
    pub fn xmtp_conversation_publish_messages(conv: *const XmtpFfiConversation) -> i32;
}
unsafe extern "C" {
    #[doc = " Prepare a message for later publishing (optimistic send workflow).\n Stores the message locally without publishing. Returns message ID (hex) via `out_id`.\n Caller must free `out_id` with [`xmtp_free_string`]."]
    pub fn xmtp_conversation_prepare_message(
        conv: *const XmtpFfiConversation,
        content_bytes: *const u8,
        content_len: i32,
        should_push: i32,
        out_id: *mut *mut ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Publish a previously prepared message by its hex-encoded ID."]
    pub fn xmtp_conversation_publish_stored_message(
        conv: *const XmtpFfiConversation,
        message_id_hex: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " List messages in this conversation. Caller must free with [`xmtp_message_list_free`]."]
    pub fn xmtp_conversation_list_messages(
        conv: *const XmtpFfiConversation,
        opts: *const XmtpFfiListMessagesOptions,
        out: *mut *mut XmtpFfiMessageList,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Count messages matching the given filter options.\n Pass null for `opts` to count all messages."]
    pub fn xmtp_conversation_count_messages(
        conv: *const XmtpFfiConversation,
        opts: *const XmtpFfiListMessagesOptions,
    ) -> i64;
}
unsafe extern "C" {
    pub fn xmtp_message_list_len(list: *const XmtpFfiMessageList) -> i32;
}
unsafe extern "C" {
    #[doc = " Get message ID (hex) at index. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_message_id(list: *const XmtpFfiMessageList, index: i32)
    -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get sender inbox ID at index. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_message_sender_inbox_id(
        list: *const XmtpFfiMessageList,
        index: i32,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get sent-at timestamp (ns) at index."]
    pub fn xmtp_message_sent_at_ns(list: *const XmtpFfiMessageList, index: i32) -> i64;
}
unsafe extern "C" {
    #[doc = " Get message kind at index: 0=Application, 1=MembershipChange, -1=error."]
    pub fn xmtp_message_kind(list: *const XmtpFfiMessageList, index: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " Get delivery status at index: 0=Unpublished, 1=Published, 2=Failed, -1=error."]
    pub fn xmtp_message_delivery_status(list: *const XmtpFfiMessageList, index: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " Get raw decrypted content bytes at index. Writes length to `out_len`.\n The returned pointer is borrowed from the list — do NOT free it."]
    pub fn xmtp_message_content_bytes(
        list: *const XmtpFfiMessageList,
        index: i32,
        out_len: *mut i32,
    ) -> *const u8;
}
unsafe extern "C" {
    pub fn xmtp_message_list_free(ptr: *mut XmtpFfiMessageList);
}
unsafe extern "C" {
    pub fn xmtp_message_free(ptr: *mut XmtpFfiMessage);
}
unsafe extern "C" {
    #[doc = " List group members. Caller must free with [`xmtp_group_member_list_free`]."]
    pub fn xmtp_conversation_list_members(
        conv: *const XmtpFfiConversation,
        out: *mut *mut XmtpFfiGroupMemberList,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_group_member_list_len(list: *const XmtpFfiGroupMemberList) -> i32;
}
unsafe extern "C" {
    #[doc = " Get member inbox ID at index. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_group_member_inbox_id(
        list: *const XmtpFfiGroupMemberList,
        index: i32,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get member permission level at index: 0=Member, 1=Admin, 2=SuperAdmin, -1=error."]
    pub fn xmtp_group_member_permission_level(
        list: *const XmtpFfiGroupMemberList,
        index: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get member consent state at index: 0=Unknown, 1=Allowed, 2=Denied, -1=error."]
    pub fn xmtp_group_member_consent_state(list: *const XmtpFfiGroupMemberList, index: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " Get member account identifiers at index.\n Returns a borrowed pointer to the internal string array. Do NOT free individual strings.\n Use `out_count` to get the number of identifiers."]
    pub fn xmtp_group_member_account_identifiers(
        list: *const XmtpFfiGroupMemberList,
        index: i32,
        out_count: *mut i32,
    ) -> *const *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get member installation IDs (hex) at index.\n Returns a borrowed pointer to the internal string array."]
    pub fn xmtp_group_member_installation_ids(
        list: *const XmtpFfiGroupMemberList,
        index: i32,
        out_count: *mut i32,
    ) -> *const *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Free a group member list."]
    pub fn xmtp_group_member_list_free(list: *mut XmtpFfiGroupMemberList);
}
unsafe extern "C" {
    #[doc = " Add members by inbox IDs."]
    pub fn xmtp_conversation_add_members(
        conv: *const XmtpFfiConversation,
        inbox_ids: *const *const ::core::ffi::c_char,
        count: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Remove members by inbox IDs."]
    pub fn xmtp_conversation_remove_members(
        conv: *const XmtpFfiConversation,
        inbox_ids: *const *const ::core::ffi::c_char,
        count: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Leave the group."]
    pub fn xmtp_conversation_leave(conv: *const XmtpFfiConversation) -> i32;
}
unsafe extern "C" {
    #[doc = " Add/remove admin or super admin. `action`: 0=AddAdmin, 1=RemoveAdmin, 2=AddSuperAdmin, 3=RemoveSuperAdmin."]
    pub fn xmtp_conversation_update_admin_list(
        conv: *const XmtpFfiConversation,
        inbox_id: *const ::core::ffi::c_char,
        action: i32,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_conversation_group_name(
        conv: *const XmtpFfiConversation,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xmtp_conversation_update_group_name(
        conv: *const XmtpFfiConversation,
        value: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_conversation_group_description(
        conv: *const XmtpFfiConversation,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xmtp_conversation_update_group_description(
        conv: *const XmtpFfiConversation,
        value: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_conversation_group_image_url(
        conv: *const XmtpFfiConversation,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xmtp_conversation_update_group_image_url(
        conv: *const XmtpFfiConversation,
        value: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get conversation consent state. Writes to `out_state` (0=Unknown, 1=Allowed, 2=Denied)."]
    pub fn xmtp_conversation_consent_state(
        conv: *const XmtpFfiConversation,
        out_state: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Update conversation consent state."]
    pub fn xmtp_conversation_update_consent_state(
        conv: *const XmtpFfiConversation,
        state: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Update a permission policy on this conversation.\n `update_type`: 1=AddMember, 2=RemoveMember, 3=AddAdmin, 4=RemoveAdmin, 5=UpdateMetadata.\n `policy`: 1=Allow, 2=Deny, 3=AdminOnly, 4=SuperAdminOnly.\n `metadata_field_name`: Only used when update_type=5 (e.g. \"group_name\"). Pass null otherwise."]
    pub fn xmtp_conversation_update_permission_policy(
        conv: *const XmtpFfiConversation,
        update_type: i32,
        policy: i32,
        metadata_field_name: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Check if the conversation is active. Returns 1=active, 0=inactive, -1=error."]
    pub fn xmtp_conversation_is_active(conv: *const XmtpFfiConversation) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the membership state of the current user in this conversation.\n 0=Allowed, 1=Rejected, 2=Pending, 3=Restored, 4=PendingRemove, -1=error."]
    pub fn xmtp_conversation_membership_state(conv: *const XmtpFfiConversation) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_conversation_added_by_inbox_id(
        conv: *const XmtpFfiConversation,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xmtp_conversation_list_admins(
        conv: *const XmtpFfiConversation,
        out_count: *mut i32,
    ) -> *mut *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xmtp_conversation_list_super_admins(
        conv: *const XmtpFfiConversation,
        out_count: *mut i32,
    ) -> *mut *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xmtp_conversation_is_admin(
        conv: *const XmtpFfiConversation,
        inbox_id: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_conversation_is_super_admin(
        conv: *const XmtpFfiConversation,
        inbox_id: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Add members by external identifiers (address/passkey).\n `identifiers` and `kinds` are parallel arrays of length `count`."]
    pub fn xmtp_conversation_add_members_by_identity(
        conv: *const XmtpFfiConversation,
        identifiers: *const *const ::core::ffi::c_char,
        kinds: *const i32,
        count: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Remove members by external identifiers (address/passkey)."]
    pub fn xmtp_conversation_remove_members_by_identity(
        conv: *const XmtpFfiConversation,
        identifiers: *const *const ::core::ffi::c_char,
        kinds: *const i32,
        count: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Update the message disappearing settings for this conversation."]
    pub fn xmtp_conversation_update_disappearing_settings(
        conv: *const XmtpFfiConversation,
        settings: *const XmtpFfiDisappearingSettings,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Remove (disable) message disappearing settings for this conversation."]
    pub fn xmtp_conversation_remove_disappearing_settings(conv: *const XmtpFfiConversation) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the current message disappearing settings.\n Returns 0 on success (writes to `out`), -1 if not set or on error."]
    pub fn xmtp_conversation_disappearing_settings(
        conv: *const XmtpFfiConversation,
        out: *mut XmtpFfiDisappearingSettings,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Check if message disappearing is enabled.\n Returns 1=enabled, 0=disabled, -1=error."]
    pub fn xmtp_conversation_is_disappearing_enabled(conv: *const XmtpFfiConversation) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_conversation_app_data(conv: *const XmtpFfiConversation)
    -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xmtp_conversation_update_app_data(
        conv: *const XmtpFfiConversation,
        value: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Find duplicate DM conversations for this DM.\n Returns a conversation list. Caller must free with [`xmtp_conversation_list_free`]."]
    pub fn xmtp_conversation_duplicate_dms(
        conv: *const XmtpFfiConversation,
        out: *mut *mut XmtpFfiConversationList,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Check if the conversation is paused for a version upgrade.\n Writes the version string to `out` if paused, or null if not paused.\n Caller must free `out` with [`xmtp_free_string`].\n Returns 0 on success, -1 on error."]
    pub fn xmtp_conversation_paused_for_version(
        conv: *const XmtpFfiConversation,
        out: *mut *mut ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get debug info for this conversation.\n Caller must free string fields with [`xmtp_free_string`]."]
    pub fn xmtp_conversation_debug_info(
        conv: *const XmtpFfiConversation,
        out: *mut XmtpFfiConversationDebugInfo,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Free a conversation debug info struct (its string fields and cursor array)."]
    pub fn xmtp_conversation_debug_info_free(info: *mut XmtpFfiConversationDebugInfo);
}
unsafe extern "C" {
    #[doc = " Get HMAC keys for this conversation (including duplicate DMs).\n Returns a map via `out`. Caller must free with [`xmtp_hmac_key_map_free`]."]
    pub fn xmtp_conversation_hmac_keys(
        conv: *const XmtpFfiConversation,
        out: *mut *mut XmtpFfiHmacKeyMap,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the number of entries in an HMAC key map."]
    pub fn xmtp_hmac_key_map_len(map: *const XmtpFfiHmacKeyMap) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the group ID (hex) at index. Returns a borrowed pointer; do NOT free."]
    pub fn xmtp_hmac_key_map_group_id(
        map: *const XmtpFfiHmacKeyMap,
        index: i32,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the HMAC keys at index. Writes count to `out_count`.\n Returns a borrowed pointer to the key array; do NOT free individual keys."]
    pub fn xmtp_hmac_key_map_keys(
        map: *const XmtpFfiHmacKeyMap,
        index: i32,
        out_count: *mut i32,
    ) -> *const XmtpFfiHmacKey;
}
unsafe extern "C" {
    #[doc = " Process a raw group message received via push notification.\n Returns a list of stored messages. Caller must free with [`xmtp_message_list_free`]."]
    pub fn xmtp_conversation_process_streamed_group_message(
        conversation: *const XmtpFfiConversation,
        envelope_bytes: *const u8,
        envelope_bytes_len: i32,
        out: *mut *mut XmtpFfiMessageList,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the full group metadata (creator inbox ID + conversation type).\n Caller must free with [`xmtp_group_metadata_free`]."]
    pub fn xmtp_conversation_group_metadata(
        conversation: *const XmtpFfiConversation,
        out: *mut *mut XmtpFfiGroupMetadata,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Free a group metadata struct."]
    pub fn xmtp_group_metadata_free(meta: *mut XmtpFfiGroupMetadata);
}
unsafe extern "C" {
    #[doc = " Get the group permissions (policy type + full policy set).\n Caller must free with [`xmtp_group_permissions_free`]."]
    pub fn xmtp_conversation_group_permissions(
        conversation: *const XmtpFfiConversation,
        out: *mut *mut XmtpFfiGroupPermissions,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_group_permissions_free(ptr: *mut XmtpFfiGroupPermissions);
}
unsafe extern "C" {
    #[doc = " List enriched (decoded) messages for a conversation.\n Caller must free with [`xmtp_enriched_message_list_free`]."]
    pub fn xmtp_conversation_list_enriched_messages(
        conversation: *const XmtpFfiConversation,
        opts: *const XmtpFfiListMessagesOptions,
        out: *mut *mut XmtpFfiEnrichedMessageList,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_enriched_message_list_len(list: *const XmtpFfiEnrichedMessageList) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_enriched_message_list_get(
        list: *const XmtpFfiEnrichedMessageList,
        index: i32,
    ) -> *const XmtpFfiEnrichedMessage;
}
unsafe extern "C" {
    pub fn xmtp_enriched_message_list_free(list: *mut XmtpFfiEnrichedMessageList);
}
unsafe extern "C" {
    #[doc = " Get per-inbox last read times for a conversation.\n Caller must free with [`xmtp_last_read_time_list_free`]."]
    pub fn xmtp_conversation_last_read_times(
        conversation: *const XmtpFfiConversation,
        out: *mut *mut XmtpFfiLastReadTimeList,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_last_read_time_list_len(list: *const XmtpFfiLastReadTimeList) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_last_read_time_list_get(
        list: *const XmtpFfiLastReadTimeList,
        index: i32,
    ) -> *const XmtpFfiLastReadTimeEntry;
}
unsafe extern "C" {
    pub fn xmtp_last_read_time_list_free(list: *mut XmtpFfiLastReadTimeList);
}
unsafe extern "C" {
    #[doc = " Free an HMAC key map (including all owned data)."]
    pub fn xmtp_hmac_key_map_free(map: *mut XmtpFfiHmacKeyMap);
}
unsafe extern "C" {
    #[doc = " Create a new group conversation, optionally adding members by inbox ID.\n Pass null/0 for `member_inbox_ids`/`member_count` to create an empty group.\n Caller must free result with [`xmtp_conversation_free`]."]
    pub fn xmtp_client_create_group(
        client: *const XmtpFfiClient,
        opts: *const XmtpFfiCreateGroupOptions,
        member_inbox_ids: *const *const ::core::ffi::c_char,
        member_count: i32,
        out: *mut *mut XmtpFfiConversation,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Create a new group, adding members by identity (address/passkey).\n `identifiers` and `kinds` are parallel arrays of length `count`.\n Caller must free result with [`xmtp_conversation_free`]."]
    pub fn xmtp_client_create_group_by_identity(
        client: *const XmtpFfiClient,
        opts: *const XmtpFfiCreateGroupOptions,
        identifiers: *const *const ::core::ffi::c_char,
        kinds: *const i32,
        count: i32,
        out: *mut *mut XmtpFfiConversation,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Find or create a DM by identifier. Caller must free result with [`xmtp_conversation_free`]."]
    pub fn xmtp_client_create_dm(
        client: *const XmtpFfiClient,
        identifier: *const ::core::ffi::c_char,
        identifier_kind: i32,
        disappear_from_ns: i64,
        disappear_in_ns: i64,
        out: *mut *mut XmtpFfiConversation,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Find or create a DM by inbox ID. Caller must free result with [`xmtp_conversation_free`]."]
    pub fn xmtp_client_find_dm_by_inbox_id(
        client: *const XmtpFfiClient,
        inbox_id: *const ::core::ffi::c_char,
        out: *mut *mut XmtpFfiConversation,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Create a DM by target inbox ID. Caller must free result with [`xmtp_conversation_free`]."]
    pub fn xmtp_client_create_dm_by_inbox_id(
        client: *const XmtpFfiClient,
        inbox_id: *const ::core::ffi::c_char,
        disappear_from_ns: i64,
        disappear_in_ns: i64,
        out: *mut *mut XmtpFfiConversation,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get a conversation by hex-encoded group ID.\n Caller must free result with [`xmtp_conversation_free`]."]
    pub fn xmtp_client_get_conversation_by_id(
        client: *const XmtpFfiClient,
        hex_id: *const ::core::ffi::c_char,
        out: *mut *mut XmtpFfiConversation,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " List conversations. Caller must free result with [`xmtp_conversation_list_free`]."]
    pub fn xmtp_client_list_conversations(
        client: *const XmtpFfiClient,
        opts: *const XmtpFfiListConversationsOptions,
        out: *mut *mut XmtpFfiConversationList,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_conversation_list_len(list: *const XmtpFfiConversationList) -> i32;
}
unsafe extern "C" {
    #[doc = " Get a conversation from a list by index. Caller must free with [`xmtp_conversation_free`]."]
    pub fn xmtp_conversation_list_get(
        list: *const XmtpFfiConversationList,
        index: i32,
        out: *mut *mut XmtpFfiConversation,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_conversation_list_free(ptr: *mut XmtpFfiConversationList);
}
unsafe extern "C" {
    #[doc = " Get the sent_at_ns of the last message for a conversation list item.\n Returns 0 if no last message exists, or -1 on error."]
    pub fn xmtp_conversation_list_last_message_sent_at_ns(
        list: *const XmtpFfiConversationList,
        index: i32,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the last message for a conversation list item as an opaque FfiMessage handle.\n Returns 0 on success (writes to `out`), -1 on error or if no last message exists.\n Caller must free with `xmtp_message_free`."]
    pub fn xmtp_conversation_list_last_message(
        list: *const XmtpFfiConversationList,
        index: i32,
        out: *mut *mut XmtpFfiMessage,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the commit log fork status for a conversation list item.\n Returns -1=unknown/error, 0=not forked, 1=forked."]
    pub fn xmtp_conversation_list_is_commit_log_forked(
        list: *const XmtpFfiConversationList,
        index: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Sync welcomes (process new group invitations)."]
    pub fn xmtp_client_sync_welcomes(client: *const XmtpFfiClient) -> i32;
}
unsafe extern "C" {
    #[doc = " Sync all conversations, optionally filtering by consent states.\n `consent_states` is a parallel array of consent state values (0=Unknown, 1=Allowed, 2=Denied).\n Pass null and 0 to sync all."]
    pub fn xmtp_client_sync_all(
        client: *const XmtpFfiClient,
        consent_states: *const i32,
        consent_states_count: i32,
        out_synced: *mut i32,
        out_eligible: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Sync preferences (device sync groups only)."]
    pub fn xmtp_client_sync_preferences(
        client: *const XmtpFfiClient,
        out_synced: *mut i32,
        out_eligible: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get HMAC keys for all conversations (including duplicate DMs).\n Returns a map via `out`. Caller must free with [`xmtp_hmac_key_map_free`]."]
    pub fn xmtp_client_hmac_keys(
        client: *const XmtpFfiClient,
        out: *mut *mut XmtpFfiHmacKeyMap,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Process a raw welcome message received via push notification.\n Returns a list of conversation handles. Caller must free with [`xmtp_conversation_list_free`]."]
    pub fn xmtp_client_process_streamed_welcome_message(
        client: *const XmtpFfiClient,
        envelope_bytes: *const u8,
        envelope_bytes_len: i32,
        out: *mut *mut XmtpFfiConversationList,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get an enriched (decoded) message by its hex-encoded ID.\n Caller must free with [`xmtp_enriched_message_list_free`] (single-item list)."]
    pub fn xmtp_client_get_enriched_message_by_id(
        client: *const XmtpFfiClient,
        message_id: *const ::core::ffi::c_char,
        out: *mut *mut XmtpFfiEnrichedMessageList,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Create a group without syncing members (optimistic / offline-capable).\n Caller must free with [`xmtp_conversation_free`]."]
    pub fn xmtp_client_create_group_optimistic(
        client: *const XmtpFfiClient,
        opts: *const XmtpFfiCreateGroupOptions,
        out: *mut *mut XmtpFfiConversation,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Send a device sync request to retrieve records from another installation."]
    pub fn xmtp_device_sync_send_request(
        client: *const XmtpFfiClient,
        opts: *const XmtpFfiArchiveOptions,
        server_url: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Send a sync archive to the sync group with the given pin."]
    pub fn xmtp_device_sync_send_archive(
        client: *const XmtpFfiClient,
        opts: *const XmtpFfiArchiveOptions,
        server_url: *const ::core::ffi::c_char,
        pin: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Process a sync archive matching the given pin.\n Pass null for `pin` to process the latest archive."]
    pub fn xmtp_device_sync_process_archive(
        client: *const XmtpFfiClient,
        pin: *const ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " List archives available for import in the sync group.\n `days_cutoff` limits how far back to look.\n Caller must free with [`xmtp_available_archive_list_free`]."]
    pub fn xmtp_device_sync_list_available_archives(
        client: *const XmtpFfiClient,
        days_cutoff: i64,
        out: *mut *mut XmtpFfiAvailableArchiveList,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_available_archive_list_len(list: *const XmtpFfiAvailableArchiveList) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the pin string at index. Returns a borrowed pointer; do NOT free."]
    pub fn xmtp_available_archive_pin(
        list: *const XmtpFfiAvailableArchiveList,
        index: i32,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Get the exported_at_ns at index."]
    pub fn xmtp_available_archive_exported_at_ns(
        list: *const XmtpFfiAvailableArchiveList,
        index: i32,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Free an available archive list."]
    pub fn xmtp_available_archive_list_free(list: *mut XmtpFfiAvailableArchiveList);
}
unsafe extern "C" {
    #[doc = " Export an archive to a local file.\n `key` must be at least 32 bytes (encryption key)."]
    pub fn xmtp_device_sync_create_archive(
        client: *const XmtpFfiClient,
        path: *const ::core::ffi::c_char,
        opts: *const XmtpFfiArchiveOptions,
        key: *const u8,
        key_len: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Import a previously exported archive from a file.\n `key` must be at least 32 bytes (encryption key)."]
    pub fn xmtp_device_sync_import_archive(
        client: *const XmtpFfiClient,
        path: *const ::core::ffi::c_char,
        key: *const u8,
        key_len: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Read metadata from an archive file without loading its full contents.\n `out_elements` is a bitmask: bit 0 = Messages, bit 1 = Consent.\n `out_start_ns` / `out_end_ns` are 0 if not set. All output pointers are nullable."]
    pub fn xmtp_device_sync_archive_metadata(
        path: *const ::core::ffi::c_char,
        key: *const u8,
        key_len: i32,
        out_version: *mut u16,
        out_exported_at_ns: *mut i64,
        out_elements: *mut i32,
        out_start_ns: *mut i64,
        out_end_ns: *mut i64,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Manually sync all device sync groups.\n Writes the number of synced/eligible groups to the output pointers."]
    pub fn xmtp_device_sync_sync_all(
        client: *const XmtpFfiClient,
        out_synced: *mut i32,
        out_eligible: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Generate an inbox ID from an identifier. Caller must free with [`xmtp_free_string`].\n `nonce` defaults to 1 if 0 is passed."]
    pub fn xmtp_generate_inbox_id(
        identifier: *const ::core::ffi::c_char,
        identifier_kind: i32,
        nonce: u64,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Check whether an installation (by its public key bytes) belongs to an inbox.\n Returns 1 = authorized, 0 = not authorized. Sets last error on failure."]
    pub fn xmtp_is_installation_authorized(
        api_url: *const ::core::ffi::c_char,
        is_secure: i32,
        inbox_id: *const ::core::ffi::c_char,
        installation_id: *const u8,
        installation_id_len: i32,
        out: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Check whether an Ethereum address belongs to an inbox.\n Returns 1 = authorized, 0 = not authorized. Sets last error on failure."]
    pub fn xmtp_is_address_authorized(
        api_url: *const ::core::ffi::c_char,
        is_secure: i32,
        inbox_id: *const ::core::ffi::c_char,
        address: *const ::core::ffi::c_char,
        out: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the inbox ID for an identifier by querying the network.\n `api_url` is the gRPC host, `is_secure` controls TLS.\n Writes the inbox ID to `out` (caller must free with [`xmtp_free_string`]).\n Writes null to `out` if no inbox ID is found."]
    pub fn xmtp_get_inbox_id_for_identifier(
        api_url: *const ::core::ffi::c_char,
        is_secure: i32,
        identifier: *const ::core::ffi::c_char,
        identifier_kind: i32,
        out: *mut *mut ::core::ffi::c_char,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Create an inbox registration signature request (if needed).\n Returns null via `out` if no signature is needed.\n Caller must free with [`xmtp_signature_request_free`]."]
    pub fn xmtp_client_create_inbox_signature_request(
        client: *const XmtpFfiClient,
        out: *mut *mut XmtpFfiSignatureRequest,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Create a signature request to add a new identifier.\n Caller must free with [`xmtp_signature_request_free`]."]
    pub fn xmtp_client_add_identifier_signature_request(
        client: *const XmtpFfiClient,
        identifier: *const ::core::ffi::c_char,
        identifier_kind: i32,
        out: *mut *mut XmtpFfiSignatureRequest,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Create a signature request to revoke an identifier.\n Caller must free with [`xmtp_signature_request_free`]."]
    pub fn xmtp_client_revoke_identifier_signature_request(
        client: *const XmtpFfiClient,
        identifier: *const ::core::ffi::c_char,
        identifier_kind: i32,
        out: *mut *mut XmtpFfiSignatureRequest,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Create a signature request to revoke all other installations.\n Returns null via `out` if there are no other installations.\n Caller must free with [`xmtp_signature_request_free`]."]
    pub fn xmtp_client_revoke_all_other_installations(
        client: *const XmtpFfiClient,
        out: *mut *mut XmtpFfiSignatureRequest,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the human-readable signature text. Caller must free with [`xmtp_free_string`]."]
    pub fn xmtp_signature_request_text(
        req: *const XmtpFfiSignatureRequest,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Add an ECDSA signature to the request."]
    pub fn xmtp_signature_request_add_ecdsa(
        req: *const XmtpFfiSignatureRequest,
        signature_bytes: *const u8,
        signature_len: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Add a passkey signature to the request.\n All four byte arrays are required and must not be null."]
    pub fn xmtp_signature_request_add_passkey(
        req: *const XmtpFfiSignatureRequest,
        public_key: *const u8,
        public_key_len: i32,
        signature: *const u8,
        signature_len: i32,
        authenticator_data: *const u8,
        authenticator_data_len: i32,
        client_data_json: *const u8,
        client_data_json_len: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Add a smart contract wallet (SCW) signature to the request.\n `account_address` is the EVM account address (hex string).\n `chain_id` is the EVM chain ID (e.g. 1 for mainnet).\n `block_number` is optional; pass 0 to omit."]
    pub fn xmtp_signature_request_add_scw(
        req: *const XmtpFfiSignatureRequest,
        account_address: *const ::core::ffi::c_char,
        signature_bytes: *const u8,
        signature_len: i32,
        chain_id: u64,
        block_number: u64,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Apply a signature request to the client."]
    pub fn xmtp_client_apply_signature_request(
        client: *const XmtpFfiClient,
        req: *const XmtpFfiSignatureRequest,
    ) -> i32;
}
unsafe extern "C" {
    pub fn xmtp_signature_request_free(ptr: *mut XmtpFfiSignatureRequest);
}
unsafe extern "C" {
    #[doc = " Create a signature request to revoke specific installations by their IDs.\n `installation_ids` is an array of byte arrays, each `id_len` bytes long.\n Caller must free with [`xmtp_signature_request_free`]."]
    pub fn xmtp_client_revoke_installations_signature_request(
        client: *const XmtpFfiClient,
        installation_ids: *const *const u8,
        id_lengths: *const i32,
        count: i32,
        out: *mut *mut XmtpFfiSignatureRequest,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Create a signature request to change the recovery identifier.\n Caller must free with [`xmtp_signature_request_free`]."]
    pub fn xmtp_client_change_recovery_identifier_signature_request(
        client: *const XmtpFfiClient,
        new_identifier: *const ::core::ffi::c_char,
        identifier_kind: i32,
        out: *mut *mut XmtpFfiSignatureRequest,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Sign text with the client's installation key.\n Writes signature bytes to `out` and length to `out_len`.\n Caller must free `out` with [`xmtp_free_bytes`]."]
    pub fn xmtp_client_sign_with_installation_key(
        client: *const XmtpFfiClient,
        text: *const ::core::ffi::c_char,
        out: *mut *mut u8,
        out_len: *mut i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Verify a signature produced by `sign_with_installation_key` using an\n arbitrary public key. Does not require a client handle.\n `signature_bytes` must be exactly 64 bytes, `public_key` must be exactly 32 bytes."]
    pub fn xmtp_verify_signed_with_public_key(
        signature_text: *const ::core::ffi::c_char,
        signature_bytes: *const u8,
        signature_len: i32,
        public_key: *const u8,
        public_key_len: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Stream new conversations. Callback receives owned `*mut FfiConversation` (caller must free).\n `on_close(error, ctx)`: null error = normal close; non-null = borrowed error string.\n Caller must end with `xmtp_stream_end` and free with `xmtp_stream_free`."]
    pub fn xmtp_stream_conversations(
        client: *const XmtpFfiClient,
        conversation_type: i32,
        callback: XmtpFnConversationCallback,
        on_close: XmtpOption_FnOnCloseCallback,
        context: *mut ::core::ffi::c_void,
        out: *mut *mut XmtpFfiStreamHandle,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Stream all messages across conversations. Callback receives owned `*mut FfiMessage`.\n `consent_states` / `consent_states_count`: optional filter (null/0 = all)."]
    pub fn xmtp_stream_all_messages(
        client: *const XmtpFfiClient,
        conversation_type: i32,
        consent_states: *const i32,
        consent_states_count: i32,
        callback: XmtpFnMessageCallback,
        on_close: XmtpOption_FnOnCloseCallback,
        context: *mut ::core::ffi::c_void,
        out: *mut *mut XmtpFfiStreamHandle,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Stream messages for a single conversation. Callback receives owned `*mut FfiMessage`."]
    pub fn xmtp_conversation_stream_messages(
        conv: *const XmtpFfiConversation,
        callback: XmtpFnMessageCallback,
        on_close: XmtpOption_FnOnCloseCallback,
        context: *mut ::core::ffi::c_void,
        out: *mut *mut XmtpFfiStreamHandle,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Stream consent state changes. Callback receives a borrowed array of consent records\n (`*const FfiConsentRecord`) — valid only during the callback invocation."]
    pub fn xmtp_stream_consent(
        client: *const XmtpFfiClient,
        callback: XmtpFnConsentCallback,
        on_close: XmtpOption_FnOnCloseCallback,
        context: *mut ::core::ffi::c_void,
        out: *mut *mut XmtpFfiStreamHandle,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Stream preference updates (consent changes + HMAC key rotations).\n Callback receives a borrowed array (`*const FfiPreferenceUpdate`) — valid only during callback."]
    pub fn xmtp_stream_preferences(
        client: *const XmtpFfiClient,
        callback: XmtpFnPreferenceCallback,
        on_close: XmtpOption_FnOnCloseCallback,
        context: *mut ::core::ffi::c_void,
        out: *mut *mut XmtpFfiStreamHandle,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Stream message deletion events. Callback receives a borrowed hex message ID\n (`*const c_char`) — valid only during the callback invocation.\n Now includes `on_close` for API consistency with other stream functions."]
    pub fn xmtp_stream_message_deletions(
        client: *const XmtpFfiClient,
        callback: XmtpFnMessageDeletionCallback,
        on_close: XmtpOption_FnOnCloseCallback,
        context: *mut ::core::ffi::c_void,
        out: *mut *mut XmtpFfiStreamHandle,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Signal a stream to stop. Does NOT free the handle — call `xmtp_stream_free` afterwards.\n Safe to call multiple times."]
    pub fn xmtp_stream_end(handle: *const XmtpFfiStreamHandle);
}
unsafe extern "C" {
    #[doc = " Check if a stream has finished. Returns 1 if closed, 0 if active."]
    pub fn xmtp_stream_is_closed(handle: *const XmtpFfiStreamHandle) -> i32;
}
unsafe extern "C" {
    #[doc = " Free a stream handle. Must be called after `xmtp_stream_end`.\n Calling this on an active (non-ended) stream will also end it."]
    pub fn xmtp_stream_free(handle: *mut XmtpFfiStreamHandle);
}
